{
    "docs": [
        {
            "location": "/", 
            "text": "I am a readme", 
            "title": "Home"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/", 
            "text": "", 
            "title": "Rstudio"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/", 
            "text": "italic\n\n\nbold\n\n\nHeader 1\n\n\nHeader 2\n\n\nHeader 3\n\n\n\n\nitem 1\n\n\n\n\nitem 2\n\n\n\n\nsubitem a\n\n\nsubitem b\n\n\n\n\n\n\n\n\nfirst item\n\n\n\n\nanother item\n\n\nsubitem a\n\n\nsubitem b\n\n\n\n\n\n\n\n\nThese two markdown lines will be on the same line.\n\n\nSeparate new lines by pressing enter twice.\n\n\n\n\nR Code Blocks\n\n\nShow both code and outcome:\n\n\nhead(cars, params$show_n)\n\n##    speed dist\n## 1      4    2\n## 2      4   10\n## 3      7    4\n## 4      7   22\n## 5      8   16\n## 6      9   10\n## 7     10   18\n## 8     10   26\n## 9     10   34\n## 10    11   17\n\n\n\nShow only outcome:\n\n\n## [1] 2", 
            "title": "Rmarkdown"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#header-1", 
            "text": "", 
            "title": "Header 1"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#header-2", 
            "text": "", 
            "title": "Header 2"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#header-3", 
            "text": "item 1   item 2   subitem a  subitem b     first item   another item  subitem a  subitem b     These two markdown lines will be on the same line.  Separate new lines by pressing enter twice.", 
            "title": "Header 3"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#r-code-blocks", 
            "text": "Show both code and outcome:  head(cars, params$show_n)\n\n##    speed dist\n## 1      4    2\n## 2      4   10\n## 3      7    4\n## 4      7   22\n## 5      8   16\n## 6      9   10\n## 7     10   18\n## 8     10   26\n## 9     10   34\n## 10    11   17  Show only outcome:  ## [1] 2", 
            "title": "R Code Blocks"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/", 
            "text": "Arithmetic operators\n\n\nYou can do mathematical operations in R.\n\n\n2 + 2\n\n## [1] 4\n\n10 - 2.34\n\n## [1] 7.66\n\n5 * 12\n\n## [1] 60\n\n99 / 11\n\n## [1] 9\n\n2^4\n\n## [1] 16\n\n(100 - 13) * 3^2\n\n## [1] 783\n\n\n\n \n\n\nObjects and the Assignment Operator \\\n-\n\n\nIn R, you can store data, statistics, and other information in\n\nobjects\n. Objects are represented by a variable name, and are created\nby using the assignment operator \\\n-\n\n\nanumber \n- 2 + 2  # We're storing the result of 2+2 in the object \"anumber\"\nanumber  # This will print the object.\n\n## [1] 4\n\n# Note: The # symbol begins a comment, and everything following a # will not affect your code.\n\n\n\nYou can also use = instead of \\\n- ...\n\n\nanumber = 9.123\nanumber\n\n## [1] 9.123\n\n\n\nbut it's better to use \\\n- to differentiate between assigning something\nto an object and other uses of =, which we'll get to later. You can\nthink of the leftwards arrow as storing data \nin\n the object, rather\nthan just setting a variable equal to some value.\n\n\n \n\n\nObject Classes with class( )\n\n\nEvery object in R has a \nclass\n, or a type that describes the content\nand organization of an object.\n\n\nclass(anumber)\n\n## [1] \"numeric\"\n\n\n\nOur object 'anumber' is of the class \nnumeric\n. There are a few other\nclasses of object in R:\n\n\nalogical \n- TRUE  # This class is called \"logical\", and takes the value TRUE or FALSE\nclass(alogical)\n\n## [1] \"logical\"\n\nacharacter \n- \"data is\"  # This class is called \"character\", and holds strings of text\nclass(acharacter)\n\n## [1] \"character\"\n\n\n\n... plus many other more complex classes, some of which we'll cover\nlater.\n\n\n \n\n\nChanging object classes\n\n\nSometimes you need to change the class of an object. You can \ncoerce\n\nsome object classes by using as.numeric( ), as.logical( ), as.character(\n), and as.integer( ).\n\n\na \n- \"1\"\nclass(a)\n\n## [1] \"character\"\n\nas.integer(a)\n\n## [1] 1\n\nclass(as.integer(a))\n\n## [1] \"integer\"\n\nb \n- 14\nclass(b)\n\n## [1] \"numeric\"\n\nas.character(b)\n\n## [1] \"14\"\n\nclass(as.character(b))\n\n## [1] \"character\"\n\nc \n- 1\nd \n- 0\nclass(c)\n\n## [1] \"numeric\"\n\nclass(d)\n\n## [1] \"numeric\"\n\nas.logical(c)\n\n## [1] TRUE\n\nas.logical(d)\n\n## [1] FALSE\n\nclass(as.logical(c))\n\n## [1] \"logical\"\n\nclass(as.logical(d))\n\n## [1] \"logical\"\n\n\n\n \n\n\nCombining things with c( )\n\n\nWe use c( ) to \ncombine\n or \nconcatenate\n \nelements\n (numbers,\nintegers, logical values, or character strings):\n\n\nsomenumbers \n- c(5.234, 3, 10.1, 900)\nsomelogical \n- c(TRUE, TRUE, FALSE, TRUE, FALSE)\nsomecharacter \n- c(\"Princeton\", \"Yale\", \"Harvard\", \"Penn\")\nsomenumbers\n\n## [1]   5.234   3.000  10.100 900.000\n\nsomelogical\n\n## [1]  TRUE  TRUE FALSE  TRUE FALSE\n\nsomecharacter\n\n## [1] \"Princeton\" \"Yale\"      \"Harvard\"   \"Penn\"\n\n\n\nc( ) is a \nfunction\n that combines various arguments or \nelements\n\nto form a \nvector\n, a one-dimensional series of values. class( ) is\nalso a function, which returns the class of the object in parentheses.\n\n\n\n\nTip: Help with functions\n\n\nYou can access the help page for a function by using the ? mark. Try\ntyping ?c into the console. ? will try to access the help page for a\nparticular command, while ?? will search the help pages.\n\n\n \n\n\nRecap: Objects, Classes, \n Vectors\n\n\nTo recap, information we work with in R is stored in \nobjects\n. Each\nobject has one or more \nclass\n (or type). Four types of \nvectors\n\n(one dimensional objects) are:\n\n\n\n\nNumeric\n: numbers with decimal values\n\n\nIntegers\n: numbers without decimal values\n\n\nLogical\n: True or False\n\n\nCharacter\n: strings of text\n\n\n\n\n \n\n\ndata.frames - Another kind of object\n\n\nA data.frame is another kind of object, where data are stored in a\nmatrix or table-like format. Let's try creating a simple data frame with\none row and three columns for each participant in a research study: \"id\"\ncontains a unique number to identify each participant, \"condition\"\nindicates whether each participant was assigned to condition A or\ncondition B, and \"rt\" is the reaction time in a task.\n\n\nYou'll see some new functions in the code below.\n\n\n# We use data.frame() to create a new data.frame from scratch.\nmydata \n- data.frame(id = seq(1:50),  # create a column named \"id\" with the numbers (sequence) 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\nclass(mydata)\n\n## [1] \"data.frame\"\n\n\n\nNow we've created a data.frame with 50 rows and 3 columns. You can\nexamine the first few rows by using the head( ) function:\n\n\nhead(mydata)\n\n##   id condition        rt\n## 1  1         A  83.26001\n## 2  2         B  83.14863\n## 3  3         A  82.55561\n## 4  4         B  86.87352\n## 5  5         A  88.35570\n## 6  6         B 113.30233\n\n\n\nYou can also view the full data.frame itself by entering \"mydata\", or\nyou can view it in a table by entering View(mydata) or clicking on the\nmydata object in the Environment tab in RStudio.\n\n\n \n\n\nReading data from a file\n\n\nOften, the data you want to analyze is located in a separate file. To\nwork with it in R, you need to \nread\n in the data.\n\n\n\n\nThere are a few different functions for reading data into R, depending\non the type of data file.\n\n\n#mydata \n- read.csv() # read.csv() is used for Comma Separated Value files\n#mydata \n- read.delim() # read.delim() is used when your data are separated/delimited by the TAB character\n#mydata \n- read.table()", 
            "title": "R basics"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#arithmetic-operators", 
            "text": "You can do mathematical operations in R.  2 + 2\n\n## [1] 4\n\n10 - 2.34\n\n## [1] 7.66\n\n5 * 12\n\n## [1] 60\n\n99 / 11\n\n## [1] 9\n\n2^4\n\n## [1] 16\n\n(100 - 13) * 3^2\n\n## [1] 783", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#objects-and-the-assignment-operator-", 
            "text": "In R, you can store data, statistics, and other information in objects . Objects are represented by a variable name, and are created\nby using the assignment operator \\ -  anumber  - 2 + 2  # We're storing the result of 2+2 in the object \"anumber\"\nanumber  # This will print the object.\n\n## [1] 4\n\n# Note: The # symbol begins a comment, and everything following a # will not affect your code.  You can also use = instead of \\ - ...  anumber = 9.123\nanumber\n\n## [1] 9.123  but it's better to use \\ - to differentiate between assigning something\nto an object and other uses of =, which we'll get to later. You can\nthink of the leftwards arrow as storing data  in  the object, rather\nthan just setting a variable equal to some value.", 
            "title": "Objects and the Assignment Operator \\&lt;-"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#object-classes-with-class", 
            "text": "Every object in R has a  class , or a type that describes the content\nand organization of an object.  class(anumber)\n\n## [1] \"numeric\"  Our object 'anumber' is of the class  numeric . There are a few other\nclasses of object in R:  alogical  - TRUE  # This class is called \"logical\", and takes the value TRUE or FALSE\nclass(alogical)\n\n## [1] \"logical\"\n\nacharacter  - \"data is\"  # This class is called \"character\", and holds strings of text\nclass(acharacter)\n\n## [1] \"character\"  ... plus many other more complex classes, some of which we'll cover\nlater.", 
            "title": "Object Classes with class( )"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#changing-object-classes", 
            "text": "Sometimes you need to change the class of an object. You can  coerce \nsome object classes by using as.numeric( ), as.logical( ), as.character(\n), and as.integer( ).  a  - \"1\"\nclass(a)\n\n## [1] \"character\"\n\nas.integer(a)\n\n## [1] 1\n\nclass(as.integer(a))\n\n## [1] \"integer\"\n\nb  - 14\nclass(b)\n\n## [1] \"numeric\"\n\nas.character(b)\n\n## [1] \"14\"\n\nclass(as.character(b))\n\n## [1] \"character\"\n\nc  - 1\nd  - 0\nclass(c)\n\n## [1] \"numeric\"\n\nclass(d)\n\n## [1] \"numeric\"\n\nas.logical(c)\n\n## [1] TRUE\n\nas.logical(d)\n\n## [1] FALSE\n\nclass(as.logical(c))\n\n## [1] \"logical\"\n\nclass(as.logical(d))\n\n## [1] \"logical\"", 
            "title": "Changing object classes"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#combining-things-with-c", 
            "text": "We use c( ) to  combine  or  concatenate   elements  (numbers,\nintegers, logical values, or character strings):  somenumbers  - c(5.234, 3, 10.1, 900)\nsomelogical  - c(TRUE, TRUE, FALSE, TRUE, FALSE)\nsomecharacter  - c(\"Princeton\", \"Yale\", \"Harvard\", \"Penn\")\nsomenumbers\n\n## [1]   5.234   3.000  10.100 900.000\n\nsomelogical\n\n## [1]  TRUE  TRUE FALSE  TRUE FALSE\n\nsomecharacter\n\n## [1] \"Princeton\" \"Yale\"      \"Harvard\"   \"Penn\"  c( ) is a  function  that combines various arguments or  elements \nto form a  vector , a one-dimensional series of values. class( ) is\nalso a function, which returns the class of the object in parentheses.", 
            "title": "Combining things with c( )"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#tip-help-with-functions", 
            "text": "You can access the help page for a function by using the ? mark. Try\ntyping ?c into the console. ? will try to access the help page for a\nparticular command, while ?? will search the help pages.", 
            "title": "Tip: Help with functions"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#recap-objects-classes-vectors", 
            "text": "To recap, information we work with in R is stored in  objects . Each\nobject has one or more  class  (or type). Four types of  vectors \n(one dimensional objects) are:   Numeric : numbers with decimal values  Integers : numbers without decimal values  Logical : True or False  Character : strings of text", 
            "title": "Recap: Objects, Classes, &amp; Vectors"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#dataframes-another-kind-of-object", 
            "text": "A data.frame is another kind of object, where data are stored in a\nmatrix or table-like format. Let's try creating a simple data frame with\none row and three columns for each participant in a research study: \"id\"\ncontains a unique number to identify each participant, \"condition\"\nindicates whether each participant was assigned to condition A or\ncondition B, and \"rt\" is the reaction time in a task.  You'll see some new functions in the code below.  # We use data.frame() to create a new data.frame from scratch.\nmydata  - data.frame(id = seq(1:50),  # create a column named \"id\" with the numbers (sequence) 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\nclass(mydata)\n\n## [1] \"data.frame\"  Now we've created a data.frame with 50 rows and 3 columns. You can\nexamine the first few rows by using the head( ) function:  head(mydata)\n\n##   id condition        rt\n## 1  1         A  83.26001\n## 2  2         B  83.14863\n## 3  3         A  82.55561\n## 4  4         B  86.87352\n## 5  5         A  88.35570\n## 6  6         B 113.30233  You can also view the full data.frame itself by entering \"mydata\", or\nyou can view it in a table by entering View(mydata) or clicking on the\nmydata object in the Environment tab in RStudio.", 
            "title": "data.frames - Another kind of object"
        }, 
        {
            "location": "/0-getting-started/0d-rbasics/#reading-data-from-a-file", 
            "text": "Often, the data you want to analyze is located in a separate file. To\nwork with it in R, you need to  read  in the data.   There are a few different functions for reading data into R, depending\non the type of data file.  #mydata  - read.csv() # read.csv() is used for Comma Separated Value files\n#mydata  - read.delim() # read.delim() is used when your data are separated/delimited by the TAB character\n#mydata  - read.table()", 
            "title": "Reading data from a file"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/", 
            "text": "```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n\n\n\n### Indexing Data\n\n#### Indexing with Brackets\n\nYou'll often need to refer to only part of an object, such as a single value in a vector, or a single row, column, or other portion of a data.frame. In R, you can use brackets [ ] after an object's name to select a _subset_ of the object (also called _indexing_):\n\n``` {r}\navector \n- c(3, 6, 9, 12, 15, 18, 21, 24, 27)  # Let's create a vector with 9 elements.\navector # prints the whole object\navector[4] # prints the fourth element of the vector\navector[4:7] # prints the 4th through 7th elements of the vector\n\n\n\n\n\n\nFor two dimensional objects like data.frames, you enter two numbers in the bracket: the first is the row (or rows) you want to select, and the second is the column(s):\n\n\n# First, let's recreate our random data.frame:\nmydata \n- data.frame(id = seq(1:50),  # create a column named \nid\n with the numbers (sequence) 1 through 50\n                     condition = rep(c(\nA\n, \nB\n), 25),  # create a \ncondition\n column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \nrt\n with randomly generated data\n\nhead(mydata)  # Let's print the head of the data for reference.\n\nmydata[1, 3]  # select a single cell in the first row, third column\n# You'll see from the printout of head(mydata) above that this is the reaction time for participant 1.\n\nmydata[3, ]  # leave one of the numbers blank if you want to select all columns for a given row\n\nmydata[, 3]  # or all rows for a given column\n\nmydata[1:10, ]  # You can select multiple rows and/or columns. Here, we're selecting the first ten rows, all columns.\n\nmydata[c(1, 3, 5),]  # This will select the first, third, and fifth rows, all columns.\n\n\n\n\n\n\nNote that you always need to include the comma when using brackets to subset a two-dimensional object like a data-frame. If you try mydata[1], you will get an error (because R doesn't know whether you're referring to the first row or column)\n\n\n\n\nUsually, your data will have column names (like ours: id, condition, \n rt). There is a better way to select and manipulate entire columns of data by referring to the column name. In a data.frame, each column is a vector of values, and you can select that vector by calling the name of the data.frame followed by the $ symbol and then the column name:\n\n\nmydata$rt\nmydata$condition\n\n\n\n\n\n\nBecause each column is a vector, you can use both the dollar sign notation and brackets to select a single value from a single column:\n\n\nmydata$rt[10]\n# is the same as:\nmydata[10, 3]\n\n\n\n\n\n\n\n\n\nConditional Indexing\n\n\nSometimes, you need to \nconditionally\n select part of an object - for example, you need only the rows where reaction time is greater than 100. You can use \n, \n, \n=, \n=, and == in brackets to do this:\n\n\nmydata[mydata$rt \n 120, ]  # Select rows of mydata where reaction time is greater than 120, all columns\n\n\n\n\nHow does this work? Let's see what's going on inside the brackets.\n\n\nmydata$rt \n 120\n\n\n\n\nThis returns a logical vector with 50 values (one for each row), where each value indicates whether each item in the vector mydata$rt is greater than 120. When we include this in the brackets before the comma, R will select only the rows where the statement is TRUE.\n\n\n\n\nHere are a few other examples of conditional indexing:\n\n\nmydata[mydata$id \n= 10,]\nmydata[mydata$condition == \nA\n, ]\n\n\n\n\nNotice that in the second example, we use the \"double equals\" sign to select the rows of mydata where condition is A. We use == instead of = for conditional formatting to differentiate it from other uses of the = sign. You could read this as \"mydata where condition is equal to A\".\n\n\n\n\n\n\nBoolean Operators \n Conditional Indexing\n\n\nSometimes, you might need to use multiple conditions to select the data you want. For example, you might need all rows of mydata where reaction time is greater than 100, but less than 110. In R, you use the \n symbol to combine conditions when both must be true.\n\n\nmydata[mydata$rt \n 100 \n mydata$rt \n 110, ]  # Select rows of mydata where reaction time is greater than 100 and less than 110, all columns\n\n\n\n\nYou should use the \n symbol when both conditions must be TRUE in order to select the data you need.\n\n\n\n\nYou might need to select part of an object depending on either one of two conditions. For example, you might need all rows of mydata where reaction time is less than 90 OR greater than 130. In R, you use the | (pronounced \"or\") symbol to combine conditions when either is true.\n\n\nmydata[mydata$rt \n 90 | mydata$rt \n 130, ]  # Select rows of mydata where rt is less than 90 or greater than 130, all columns\n\n\n\n\n\n\nWhen stringing together many \n and | statements, you can use parentheses to control the order of operations. Suppose we need the data for only the first 10 participants with extreme reaction times (\n 90 or \n 130). We could try:\n\n\nmydata[mydata$id \n= 10 \n mydata$rt \n 90 | mydata$rt \n 130, ]\n\n\n\n\nUh oh. We shouldn't have that fourth row, because they aren't one of the first ten participants. R includes that row because of the last OR statement (the reaction time is \n 130). The correct way is:\n\n\nmydata[mydata$id \n= 10 \n (mydata$rt \n 90 | mydata$rt \n 130), ]\n\n\n\n\nThe parentheses make sure that R evaluates the OR parts before the AND part.\n\n\n\n\n\n\nThe subset( ) function\n\n\nThere are many other ways to subset your data in R, using functions instead of brackets. One alternative is the subset( ) function. The subset function takes at least 2 \narguments\n, the things you include inside of the parentheses when calling a function. The first argument is the object to be subsetted, and the second is a logical expression indicating which elements or rows to keep.\n\n\nsubset(mydata, rt \n 130) # This selects all rows of mydata where rt \n 130\n\n\n\n\nYou can also indicate which columns you'd like to keep in the subset( ) function:\n\n\nsubset(mydata, rt \n 130, c(condition, rt))  # select the condition and rt columns where rt \n 130\n\n\n\n\nYou can be more explicit with the arguments if you'd like:\n\n\nsubset(x = mydata, subset = rt \n 130, select = c(condition, rt)) # This is the same as the last example, but noting each argument explicitly\n\n\n\n\nIf you don't specify the arguments in this way, R will guess which code to pass to which argument.\n\n\n\n\n\n\n\n\nSummarizing Data\n\n\nNow you know how to select different columns, rows, and cells of your data. Let's learn some new functions that will help you summarize your data. We'll focus on the reaction time data for our dataset.\n\n\nmean(mydata$rt)  # Gives the mean (average) of RT\nsd(mydata$rt)  # Gives the standard deviation of RT\nmedian(mydata$rt)  # Gives the median value\nmin(mydata$rt)  # Gives the minimum value\nmax(mydata$rt)  # Gives the maximum value\n\n\n\n\n\n\n\n\n\n\nSome Basic Data Visualization\n\n\nLet's review a few functions that create basic, simple visualizations of your data.\n\n\n\n\nHistograms\n\n\nOne of your first steps in analyzing any data should be to look at the histogram of your dependent variable. How is the data distributed? Is it normal? Is it skewed? Are there any outliers?\n\n\nThe hist( ) function is the simplest way to view a histogram of any vector.\n\n\nhist(mydata$rt)\n\n\n\n\nThe data appear to be more or less normally distributed, without any notable outliers. (This makes sense, since we generated the data by sampling randomly from a normal distribution.) You can add some arguments to the hist( ) function to alter the plot. (Remember, you can use TAB while inside the function's parentheses to see a list of arguments and what they do.)\n\n\nhist(mydata$rt, breaks = 10)  # breaks supplies the number of breaks in the histogram (???)\nhist(mydata$rt, breaks = 10, freq = F)  # setting freq = F changes the y-axis to probability density instead of count/frequency\nhist(mydata$rt, breaks = 10, density = 10)  # density sets the density of shading\nhist(mydata$rt, breaks = 10, xlab = \nReaction Time\n)  # xlab and ylab change the labels on the X and Y axes.\n\n\n\n\n\n\n\n\nBoxplots\n\n\nA boxplot is a good way to compare the distributions of data across groups or conditions. Here's an example that plots and compares our reaction time in conditions A and B.\n\n\nboxplot(mydata$rt ~ mydata$condition, xlab = \nCondition\n, ylab = \nReaction Time\n)\n\n\n\n\nYou'll notice the new ~ symbol in the code. The ~ symbol is used in R to write formulas, with the dependent variable in the left and the grouping variable on the right. Here, we're telling R that we want a boxplot of mydata$rt, grouped according to mydata$condition.\n\n\nThe dark solid line indicates the median value in each group. The top and bottom of the boxes are the 75th and 25th percentiles, respectively, and the endpoints reflect the range. Here, we see that reaction times are similar in conditions A and B (which makes sense, since we randomly sampled the data in each condition from the same distribution.)", 
            "title": "Index and summarize"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#conditional-indexing", 
            "text": "Sometimes, you need to  conditionally  select part of an object - for example, you need only the rows where reaction time is greater than 100. You can use  ,  ,  =,  =, and == in brackets to do this:  mydata[mydata$rt   120, ]  # Select rows of mydata where reaction time is greater than 120, all columns  How does this work? Let's see what's going on inside the brackets.  mydata$rt   120  This returns a logical vector with 50 values (one for each row), where each value indicates whether each item in the vector mydata$rt is greater than 120. When we include this in the brackets before the comma, R will select only the rows where the statement is TRUE.   Here are a few other examples of conditional indexing:  mydata[mydata$id  = 10,]\nmydata[mydata$condition ==  A , ]  Notice that in the second example, we use the \"double equals\" sign to select the rows of mydata where condition is A. We use == instead of = for conditional formatting to differentiate it from other uses of the = sign. You could read this as \"mydata where condition is equal to A\".", 
            "title": "Conditional Indexing"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#boolean-operators-conditional-indexing", 
            "text": "Sometimes, you might need to use multiple conditions to select the data you want. For example, you might need all rows of mydata where reaction time is greater than 100, but less than 110. In R, you use the   symbol to combine conditions when both must be true.  mydata[mydata$rt   100   mydata$rt   110, ]  # Select rows of mydata where reaction time is greater than 100 and less than 110, all columns  You should use the   symbol when both conditions must be TRUE in order to select the data you need.   You might need to select part of an object depending on either one of two conditions. For example, you might need all rows of mydata where reaction time is less than 90 OR greater than 130. In R, you use the | (pronounced \"or\") symbol to combine conditions when either is true.  mydata[mydata$rt   90 | mydata$rt   130, ]  # Select rows of mydata where rt is less than 90 or greater than 130, all columns   When stringing together many   and | statements, you can use parentheses to control the order of operations. Suppose we need the data for only the first 10 participants with extreme reaction times (  90 or   130). We could try:  mydata[mydata$id  = 10   mydata$rt   90 | mydata$rt   130, ]  Uh oh. We shouldn't have that fourth row, because they aren't one of the first ten participants. R includes that row because of the last OR statement (the reaction time is   130). The correct way is:  mydata[mydata$id  = 10   (mydata$rt   90 | mydata$rt   130), ]  The parentheses make sure that R evaluates the OR parts before the AND part.", 
            "title": "Boolean Operators &amp; Conditional Indexing"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#the-subset-function", 
            "text": "There are many other ways to subset your data in R, using functions instead of brackets. One alternative is the subset( ) function. The subset function takes at least 2  arguments , the things you include inside of the parentheses when calling a function. The first argument is the object to be subsetted, and the second is a logical expression indicating which elements or rows to keep.  subset(mydata, rt   130) # This selects all rows of mydata where rt   130  You can also indicate which columns you'd like to keep in the subset( ) function:  subset(mydata, rt   130, c(condition, rt))  # select the condition and rt columns where rt   130  You can be more explicit with the arguments if you'd like:  subset(x = mydata, subset = rt   130, select = c(condition, rt)) # This is the same as the last example, but noting each argument explicitly  If you don't specify the arguments in this way, R will guess which code to pass to which argument.", 
            "title": "The subset( ) function"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#summarizing-data", 
            "text": "Now you know how to select different columns, rows, and cells of your data. Let's learn some new functions that will help you summarize your data. We'll focus on the reaction time data for our dataset.  mean(mydata$rt)  # Gives the mean (average) of RT\nsd(mydata$rt)  # Gives the standard deviation of RT\nmedian(mydata$rt)  # Gives the median value\nmin(mydata$rt)  # Gives the minimum value\nmax(mydata$rt)  # Gives the maximum value", 
            "title": "Summarizing Data"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#some-basic-data-visualization", 
            "text": "Let's review a few functions that create basic, simple visualizations of your data.", 
            "title": "Some Basic Data Visualization"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#histograms", 
            "text": "One of your first steps in analyzing any data should be to look at the histogram of your dependent variable. How is the data distributed? Is it normal? Is it skewed? Are there any outliers?  The hist( ) function is the simplest way to view a histogram of any vector.  hist(mydata$rt)  The data appear to be more or less normally distributed, without any notable outliers. (This makes sense, since we generated the data by sampling randomly from a normal distribution.) You can add some arguments to the hist( ) function to alter the plot. (Remember, you can use TAB while inside the function's parentheses to see a list of arguments and what they do.)  hist(mydata$rt, breaks = 10)  # breaks supplies the number of breaks in the histogram (???)\nhist(mydata$rt, breaks = 10, freq = F)  # setting freq = F changes the y-axis to probability density instead of count/frequency\nhist(mydata$rt, breaks = 10, density = 10)  # density sets the density of shading\nhist(mydata$rt, breaks = 10, xlab =  Reaction Time )  # xlab and ylab change the labels on the X and Y axes.", 
            "title": "Histograms"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#boxplots", 
            "text": "A boxplot is a good way to compare the distributions of data across groups or conditions. Here's an example that plots and compares our reaction time in conditions A and B.  boxplot(mydata$rt ~ mydata$condition, xlab =  Condition , ylab =  Reaction Time )  You'll notice the new ~ symbol in the code. The ~ symbol is used in R to write formulas, with the dependent variable in the left and the grouping variable on the right. Here, we're telling R that we want a boxplot of mydata$rt, grouped according to mydata$condition.  The dark solid line indicates the median value in each group. The top and bottom of the boxes are the 75th and 25th percentiles, respectively, and the endpoints reflect the range. Here, we see that reaction times are similar in conditions A and B (which makes sense, since we randomly sampled the data in each condition from the same distribution.)", 
            "title": "Boxplots"
        }
    ]
}