{
    "docs": [
        {
            "location": "/", 
            "text": "Data Analysis and Reporting with R\n\n\nData analysis is a core skill in many fields of research. \nIn this course, you will learn the fundamentals of analyzing data with R: reading in data, processing it, and performing statistical analyses. \nIn the name of preserving your sanity (and time), we put strong emphasis on organizing your R analyses, as well as generating meaningful reports and visualizations.\nNo prior programming experience necessary. \nVery mild exposure to statistics will be useful, but isn't necessary either.\n\n\nFor simple, interactive lessons on some of the topics we'll cover, see \ntryr.codeschool.com\n\n\nInstructors and Princeton Email: \n\n\n\n\nMichael Chow [machow]\n\n\nNick Rohrbaugh [rohrbaugh]\n\n\n\n\nHow to Use This Course\n\n\nBelieve it or not, everything used to create the pages of this site were done in R.\nThis was done using three tools:\n\n\n\n\nRstudio\n - an interface that makes working with R much easier.\n\n\nRmarkdown\n - a simple way to write a report that can be turned into a web page or pdf.\n\n\nR code\n - the actual R part that does the data analysis\n\n\n\n\nI'll walk you through getting the course materials, but in case you want to try beforehand there are instructions in \nthis clip\n.\n\n\nAsking Questions\n\n\nWe've set up a spot for asking questions on \npiazza (WS 145)\n. \nIf you've never used the site before, \nhere's a brief video on how to sign up and add the course\n.\n\n\nSet Up\n\n\nScreencasts\n\n\nIn case you have trouble with installing R and Rstudio, these screencasts below will walk through the process.\n\n\n\n\nWindows\n\n\nMac\n\n\nLinux (Debian)\n\n\n\n\nInstall R, Rstudio, Rmarkdown\n\n\nGo to \nthis site\n and download R by clicking the link corresponding to your operating system (shown below).\n\n\n\n\nOnce R is installed, \ndownload and install Rstudio\n. \nAt this point, you should be able to open Rstudio, but check the screencasts above if you're not sure how.\nOnce you open Rstudio, it should look something like this the image below.\n\n\n\n\nMake sure it works\n\n\nThe following screenshots will walk you through testing that everything is ready to go. If it's not clear, here is a \nvery short screen cast of the process\n. We'll explain what's happening in more detail during the workshop.\n\n\nCreate an Rmarkdown document, and install the required packages:\n\n\n\n\n\n\n Test generating a report \n\n\n\n\n\n\n Profit \n\n\nWhen your report succesfully generates, you should something similar to the image below. We'll explain what each step of this process means during the course.\n\n\n\n\nFAQ\n\n\nAs we go through the course, we will update this section based on questions that arise.\n\n\n\n\n\n\nI'm on Windows 10 and can't open Rstudio\n\nAssuming you've installed Rstudio succesfully, look at \nhow to find apps in Windows 10\n.\n\n\n\n\n\n\nWhat is a working directory?\n  \nwatch (1.5 mins)\n\nIt's where R begins when looking for a file. So if I am in my \n~/home\n directory, and use the command \nread.csv('a_file.csv')\n, then R will look for the file in that directory. \n\n\n\n\n\n\nWhat if my document won't knit?\n  \nwatch (2 mins)\n\nYou should (1) set your working directory to where the document is, (2) clear your environment, (3) run all the chunks in your document to look for errors.\nR normally stops knitting when it runs into errors.\nHowever, putting the chunk below at the top of your document will print R errors in your report.\n\n\n\n\n\n\n```{r}\nlibrary(knitr)\nopts_chunk$set(error=TRUE)\n```", 
            "title": "Home"
        }, 
        {
            "location": "/#data-analysis-and-reporting-with-r", 
            "text": "Data analysis is a core skill in many fields of research. \nIn this course, you will learn the fundamentals of analyzing data with R: reading in data, processing it, and performing statistical analyses. \nIn the name of preserving your sanity (and time), we put strong emphasis on organizing your R analyses, as well as generating meaningful reports and visualizations.\nNo prior programming experience necessary. \nVery mild exposure to statistics will be useful, but isn't necessary either.  For simple, interactive lessons on some of the topics we'll cover, see  tryr.codeschool.com  Instructors and Princeton Email:    Michael Chow [machow]  Nick Rohrbaugh [rohrbaugh]", 
            "title": "Data Analysis and Reporting with R"
        }, 
        {
            "location": "/#how-to-use-this-course", 
            "text": "Believe it or not, everything used to create the pages of this site were done in R.\nThis was done using three tools:   Rstudio  - an interface that makes working with R much easier.  Rmarkdown  - a simple way to write a report that can be turned into a web page or pdf.  R code  - the actual R part that does the data analysis   I'll walk you through getting the course materials, but in case you want to try beforehand there are instructions in  this clip .", 
            "title": "How to Use This Course"
        }, 
        {
            "location": "/#asking-questions", 
            "text": "We've set up a spot for asking questions on  piazza (WS 145) . \nIf you've never used the site before,  here's a brief video on how to sign up and add the course .", 
            "title": "Asking Questions"
        }, 
        {
            "location": "/#set-up", 
            "text": "", 
            "title": "Set Up"
        }, 
        {
            "location": "/#screencasts", 
            "text": "In case you have trouble with installing R and Rstudio, these screencasts below will walk through the process.   Windows  Mac  Linux (Debian)", 
            "title": "Screencasts"
        }, 
        {
            "location": "/#install-r-rstudio-rmarkdown", 
            "text": "Go to  this site  and download R by clicking the link corresponding to your operating system (shown below).   Once R is installed,  download and install Rstudio . \nAt this point, you should be able to open Rstudio, but check the screencasts above if you're not sure how.\nOnce you open Rstudio, it should look something like this the image below.", 
            "title": "Install R, Rstudio, Rmarkdown"
        }, 
        {
            "location": "/#make-sure-it-works", 
            "text": "The following screenshots will walk you through testing that everything is ready to go. If it's not clear, here is a  very short screen cast of the process . We'll explain what's happening in more detail during the workshop.  Create an Rmarkdown document, and install the required packages:     Test generating a report      Profit   When your report succesfully generates, you should something similar to the image below. We'll explain what each step of this process means during the course.", 
            "title": "Make sure it works"
        }, 
        {
            "location": "/#faq", 
            "text": "As we go through the course, we will update this section based on questions that arise.    I'm on Windows 10 and can't open Rstudio \nAssuming you've installed Rstudio succesfully, look at  how to find apps in Windows 10 .    What is a working directory?    watch (1.5 mins) \nIt's where R begins when looking for a file. So if I am in my  ~/home  directory, and use the command  read.csv('a_file.csv') , then R will look for the file in that directory.     What if my document won't knit?    watch (2 mins) \nYou should (1) set your working directory to where the document is, (2) clear your environment, (3) run all the chunks in your document to look for errors.\nR normally stops knitting when it runs into errors.\nHowever, putting the chunk below at the top of your document will print R errors in your report.    ```{r}\nlibrary(knitr)\nopts_chunk$set(error=TRUE)\n```", 
            "title": "FAQ"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/", 
            "text": "Data Analysis and Reporting with R\n\n\nauthor: Michael Chow and Nick Rohrbaugh\n\n\nslides here\n\n\nAbout us\n\n\nR can do a lot of things\n\n\nThis week\n\n\nMon\n -- Overview of R and making reports in Rmarkdown\n\n\nWed\n -- Basic tools and analyses\n\n\nFri\n -- Broad survey of other things\n\n\nSetup\n\n\n\n\nCreate a folder for R Projects\n\n\nOverview of R and making reports in Rmarkdown\n\n\n\n\nwhat is R?\n\n\nwhat is Rmarkdown?\n\n\nusing Rstudio for great justice.\n\n\n\n\nR in a nutshell\n\n\n 1 + 1\n\n\n\n\n[1] 2\n\n\n\n\n plot(sin(1:100*pi/50), type='l', col='blue')\n\n\n\n\n\n\nMarkdown in a nutshell\n\n\n\n\nWhy combine the two?\n\n\n\n\n\n\n\n\nR + markdown == Rmarkdown\n\n\n\n\n\n\nMaking reports with R is easy!\n\n\n\n\n\n\nCombine R and markdown\n\n\n\n\n\n\n\n\n\n\nR + markdown == Rmarkdown (cont.)\n\n\n\n\n\n\nShow R output in meaningful way\n\n\n\n\n\n\nNo copy / paste madness\n\n\n\n\n\n\nConnect code with end goal\n\n\n\n\n\n\n\n\n\n\nGetting familiar with Rstudio\n\n\nBasic Layout\n\n\n\n\nConsole\n\n\nFiles\n\n\nScripts\n\n\n(Environment)\n\n\n\n\n\n\nConcepts\n\n\n\n\nWorking Directory\n\n\nWorkspace\n\n\nKnitting\n\n\n\n\nResources\n\n\nInteractive: http://tryr.codeschool.com/\n\n\nMore interactive: http://datacamp.com\n\n\nMany links: https://www.rstudio.com/resources/training/online-learning/", 
            "title": "Rstudio"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#data-analysis-and-reporting-with-r", 
            "text": "author: Michael Chow and Nick Rohrbaugh", 
            "title": "Data Analysis and Reporting with R"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#slides-here", 
            "text": "", 
            "title": "slides here"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#about-us", 
            "text": "", 
            "title": "About us"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#r-can-do-a-lot-of-things", 
            "text": "", 
            "title": "R can do a lot of things"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#this-week", 
            "text": "Mon  -- Overview of R and making reports in Rmarkdown  Wed  -- Basic tools and analyses  Fri  -- Broad survey of other things", 
            "title": "This week"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#setup", 
            "text": "Create a folder for R Projects", 
            "title": "Setup"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#overview-of-r-and-making-reports-in-rmarkdown", 
            "text": "what is R?  what is Rmarkdown?  using Rstudio for great justice.", 
            "title": "Overview of R and making reports in Rmarkdown"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#r-in-a-nutshell", 
            "text": "1 + 1  [1] 2   plot(sin(1:100*pi/50), type='l', col='blue')", 
            "title": "R in a nutshell"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#markdown-in-a-nutshell", 
            "text": "", 
            "title": "Markdown in a nutshell"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#why-combine-the-two", 
            "text": "", 
            "title": "Why combine the two?"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#r-markdown-rmarkdown", 
            "text": "Making reports with R is easy!    Combine R and markdown", 
            "title": "R + markdown == Rmarkdown"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#r-markdown-rmarkdown-cont", 
            "text": "Show R output in meaningful way    No copy / paste madness    Connect code with end goal", 
            "title": "R + markdown == Rmarkdown (cont.)"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#getting-familiar-with-rstudio", 
            "text": "", 
            "title": "Getting familiar with Rstudio"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#basic-layout", 
            "text": "Console  Files  Scripts  (Environment)", 
            "title": "Basic Layout"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#concepts", 
            "text": "Working Directory  Workspace  Knitting", 
            "title": "Concepts"
        }, 
        {
            "location": "/0-getting-started/0a-rstudio/#resources", 
            "text": "Interactive: http://tryr.codeschool.com/  More interactive: http://datacamp.com  Many links: https://www.rstudio.com/resources/training/online-learning/", 
            "title": "Resources"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/", 
            "text": "How to style an Rmarkdown document (Header 1)\n\n\nHeader 2\n\n\nHeader 3\n\n\nText\n\n\nitalic\n\n\nbold\n\n\nLists\n\n\n\n\nitem 1\n\n\n\n\nitem 2\n\n\n\n\nsubitem a\n\n\nsubitem b\n\n\n\n\n\n\n\n\nfirst item\n\n\n\n\nanother item\n\n\nsubitem a\n\n\nsubitem b\n\n\nnew item\n\n\n\n\n\n\n\n\nSeparating lines\n\n\nThese two markdown lines will be on the same line.\n\n\nSeparate new lines by pressing enter twice.\n\n\nImages\n\n\n\n\nR Code Blocks\n\n\nShow both code and outcome:\n\n\n1 + 1\n\n## [1] 2\n\n\n\nShow only outcome:\n\n\n## [1] 2\n\n\n\nDon't run code:\n\n\n1 + 1\n\n\n\nYou can make a figure wider:\n\n\nplot(1:10)\n\n\n\n\n\nOther styles you may not need\n\n\n$$ \\sqrt{x} + \\frac{y}{x} $$\n\n\nDealing with Errors\n\n\n  ```r\n  library(knitr)\n  opts_knit$set(error=TRUE)\n  ```\n\n\n\nReferences and Cheatsheets\n\n\n\n\nRmarkdown homepage\n\n\nhtml document\n    format\n\n\nusing code\n    chunks\n\n\n\n\nPDFs\n\n\n\n\ncheatsheet\n\n\nreference\n    guide", 
            "title": "Rmarkdown"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#how-to-style-an-rmarkdown-document-header-1", 
            "text": "", 
            "title": "How to style an Rmarkdown document (Header 1)"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#header-2", 
            "text": "", 
            "title": "Header 2"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#header-3", 
            "text": "", 
            "title": "Header 3"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#text", 
            "text": "italic  bold", 
            "title": "Text"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#lists", 
            "text": "item 1   item 2   subitem a  subitem b     first item   another item  subitem a  subitem b  new item", 
            "title": "Lists"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#separating-lines", 
            "text": "These two markdown lines will be on the same line.  Separate new lines by pressing enter twice.", 
            "title": "Separating lines"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#images", 
            "text": "", 
            "title": "Images"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#r-code-blocks", 
            "text": "Show both code and outcome:  1 + 1\n\n## [1] 2  Show only outcome:  ## [1] 2  Don't run code:  1 + 1  You can make a figure wider:  plot(1:10)", 
            "title": "R Code Blocks"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#other-styles-you-may-not-need", 
            "text": "$$ \\sqrt{x} + \\frac{y}{x} $$", 
            "title": "Other styles you may not need"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#dealing-with-errors", 
            "text": "```r\n  library(knitr)\n  opts_knit$set(error=TRUE)\n  ```", 
            "title": "Dealing with Errors"
        }, 
        {
            "location": "/0-getting-started/0b-rmarkdown/#references-and-cheatsheets", 
            "text": "Rmarkdown homepage  html document\n    format  using code\n    chunks   PDFs   cheatsheet  reference\n    guide", 
            "title": "References and Cheatsheets"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/", 
            "text": "Arithmetic operators\n\n\nYou can do mathematical operations in R.\n\n\n2 + 2\n\n## [1] 4\n\n10 - 2.34\n\n## [1] 7.66\n\n5 * 12\n\n## [1] 60\n\n99 / 11\n\n## [1] 9\n\n2^4\n\n## [1] 16\n\n(100 - 13) * 3^2\n\n## [1] 783\n\n\n\n\n\nSpacing is not very important.\n\n\n2    +  2\n\n## [1] 4\n\n3*4\n\n## [1] 12\n\n\n\n \n\n\nObjects and the Assignment Operator \\\n-\n\n\nIn R, you can store data, statistics, and other information in\n\nobjects\n. Objects are represented by a variable name, and are created\nby using the assignment operator \\\n-\n\n\nanumber \n- 2 + 2  # We're storing the result of 2+2 in the variable \"anumber\"\nanumber  # This will print the object.\n\n## [1] 4\n\n# Note: The # symbol begins a comment, and everything following a # will not affect your code.\n\n\n\nYou can also use = instead of \\\n- ...\n\n\nanumber = 9.123\nanumber\n\n## [1] 9.123\n\n\n\nbut it's better to use \\\n- to differentiate between assigning something\nto a variable and other uses of =, which we'll get to later. You can\nthink of the leftwards arrow as storing data \nin\n the object, rather\nthan just setting a variable equal to some value.\n\n\n \n\n\nObject Classes with class( )\n\n\nEvery object in R has a \nclass\n, or a type that describes the content\nand organization of an object.\n\n\nclass(anumber)\n\n## [1] \"numeric\"\n\n\n\nOur object 'anumber' is of the class \nnumeric\n. There are a few other\nclasses of object in R:\n\n\nalogical \n- TRUE  # This class is called \"logical\", and takes the value TRUE or FALSE\nclass(alogical)\n\n## [1] \"logical\"\n\nacharacter \n- \"data is\"  # This class is called \"character\", and holds strings of text\nclass(acharacter)\n\n## [1] \"character\"\n\nafactor \n- factor(\"A\")  # This is a class called \"factor\". It's like character, but when elements with the same text are grouped\nclass(afactor)\n\n## [1] \"factor\"\n\n\n\n... plus many other more complex classes, some of which we'll cover\nlater.\n\n\n \n\n\nChanging object classes\n\n\nSometimes you need to change the class of an object. You can \ncoerce\n\nsome object classes by using \nas.numeric()\n, \nas.logical()\n,\n\nas.character()\n, \nas.integer()\n, and \nas.factor()\n.\n\n\na \n- \"1\"\nclass(a)\n\n## [1] \"character\"\n\nas.integer(a)\n\n## [1] 1\n\nclass(as.integer(a))\n\n## [1] \"integer\"\n\nb \n- 14\nclass(b)\n\n## [1] \"numeric\"\n\nas.character(b)\n\n## [1] \"14\"\n\nclass(as.character(b))\n\n## [1] \"character\"\n\nas.factor(b)\n\n## [1] 14\n## Levels: 14\n\nclass(as.factor(b))\n\n## [1] \"factor\"\n\nc \n- 1\nd \n- 0\nclass(c)\n\n## [1] \"numeric\"\n\nclass(d)\n\n## [1] \"numeric\"\n\nas.logical(c)\n\n## [1] TRUE\n\nas.logical(d)\n\n## [1] FALSE\n\nclass(as.logical(c))\n\n## [1] \"logical\"\n\nclass(as.logical(d))\n\n## [1] \"logical\"\n\n\n\n \n\n\nCombining things with \nc()\n\n\nWe use \nc()\n to \ncombine\n or \nconcatenate\n \nelements\n (numbers,\nintegers, logical values, or character strings):\n\n\nsomenumbers \n- c(5.234, 3, 10.1, 900)\nsomelogical \n- c(TRUE, TRUE, FALSE, TRUE, FALSE)\nsomecharacter \n- c(\"Princeton\", \"Yale\", \"Harvard\", \"Penn\")\nsomefactor \n- factor(c(\"A\", \"B\", \"C\", \"B\", \"B\", \"A\"))\nsomenumbers\n\n## [1]   5.234   3.000  10.100 900.000\n\nsomelogical\n\n## [1]  TRUE  TRUE FALSE  TRUE FALSE\n\nsomecharacter\n\n## [1] \"Princeton\" \"Yale\"      \"Harvard\"   \"Penn\"\n\nsomefactor\n\n## [1] A B C B B A\n## Levels: A B C\n\n\n\nc()\n is a \nfunction\n that combines various arguments or \nelements\n\nto form a \nvector\n, a one-dimensional series of values.\n\n\n\n\nA function is like a command that takes several \narguments\n and\nreturns a result. In R, you call functions with a function name followed\nby a set of parentheses. Inside of the parentheses go what are called\narguments, which indicate various details about how the function should\noperate. In the \nc()\n function, the arguments of inside the parentheses\nafter the c are the things to be combined.\n\n\n\n\nWe've used a few other functions so far. \nclass()\n is a function that\nreturns the class of the object in parentheses. \nas.integer()\n and the\nother coercion functions change the class of the object in parentheses.\n\nfactor()\n encodes its argument as a factor.\n\n\n\n\nThere are many \nbase\n functions in R, i.e. functions that are built-in\nand ready to use. Sometimes, you might need to do something that isn't\neasily done with the base functions. In R, you can install \npackages\n,\nwhich include additional functions written by other R users. You can\ninstall packages using the \ninstall.packages()\n function, and load them\nusing \nlibrary()\n. For example, to install the psych library, use\n\ninstall.packages('psych')\n.\n\n\n\n\nThis code loads the \"psych\" package, which provides some functions that\nare useful for doing statistical analyses of experimental data.\n\n\nlibrary(psych)\n\n\n\n \n\n\nTip: Help with functions\n\n\nYou can access the help page for a function by using the ? mark. This\nwill show you information about what the function does and which\narguments you can specify. Try typing ?c into the console. ? will try to\naccess the help page for a particular command, while ?? will search the\nhelp pages.\n\n\n \n\n\nRecap: Objects, Classes, Vectors, \n Functions\n\n\nTo recap, information we work with in R is stored in \nobjects\n. Each\nobject has one or more \nclass\n (or type). Four types of \nvectors\n\n(one dimensional objects) are:\n\n\n\n\nNumeric\n: numbers with decimal values\n\n\nIntegers\n: numbers without decimal values\n\n\nLogical\n: True or False\n\n\nCharacter\n: strings of text\n\n\nFactor\n: strings of text that indicate groups, conditions, etc.\n\n\n\n\nFunctions\n are commands that execute code, and contain \narguments\n\nthat detail how to do so.\n\n\n \n\n\ndata.frames - Another kind of object\n\n\nA data.frame is another kind of object, where data are stored in a\nmatrix or table-like format. Let's try creating a simple data frame with\none row and three columns for each participant in a research study: \"id\"\ncontains a unique number to identify each participant, \"condition\"\nindicates whether each participant was assigned to condition A or\ncondition B, and \"rt\" is the reaction time in a task.\n\n\nYou'll see some new functions in the code below.\n\n\n# We use data.frame() to create a new data.frame from scratch.\nmydata \n- data.frame(id = seq(1:50),  # create a column named \"id\" with the numbers (sequence) 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\nclass(mydata)\n\n## [1] \"data.frame\"\n\n\n\nNow we've created a data.frame with 50 rows and 3 columns. You can\nexamine the first few rows by using the head( ) function:\n\n\nhead(mydata)\n\n##   id condition        rt\n## 1  1         A  99.21827\n## 2  2         B 121.28731\n## 3  3         A 105.02078\n## 4  4         B  97.96730\n## 5  5         A  83.37108\n## 6  6         B 104.58375\n\n\n\nYou can also view the full data.frame itself by entering \"mydata\", or\nyou can view it in a table by entering \nView(mydata)\n or clicking on the\nmydata object in the Environment tab in RStudio.\n\n\nA simple way to summarize data is through the \nsummary\n function:\n\n\nsummary(mydata)\n\n##        id        condition       rt        \n##  Min.   : 1.00   A:25      Min.   : 67.10  \n##  1st Qu.:13.25   B:25      1st Qu.: 85.94  \n##  Median :25.50             Median : 96.99  \n##  Mean   :25.50             Mean   : 97.83  \n##  3rd Qu.:37.75             3rd Qu.:109.23  \n##  Max.   :50.00             Max.   :134.91\n\n\n\n \n\n\nReading data from a file\n\n\nOften, the data you want to analyze is located in a separate file. To\nwork with it in R, you need to \nread\n in the data.\n\n\n\n\nThere are a few different functions for reading data into R, depending\non the type of data file.\n\n\nmydata \n- read.csv(\"../data/training_long.csv\") # read.csv() is used for Comma Separated Value files\n#mydata \n- read.delim() # read.delim() is used when your data are separated/delimited by the TAB character\n#mydata \n- read.table()", 
            "title": "R language"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#arithmetic-operators", 
            "text": "You can do mathematical operations in R.  2 + 2\n\n## [1] 4\n\n10 - 2.34\n\n## [1] 7.66\n\n5 * 12\n\n## [1] 60\n\n99 / 11\n\n## [1] 9\n\n2^4\n\n## [1] 16\n\n(100 - 13) * 3^2\n\n## [1] 783   Spacing is not very important.  2    +  2\n\n## [1] 4\n\n3*4\n\n## [1] 12", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#objects-and-the-assignment-operator-", 
            "text": "In R, you can store data, statistics, and other information in objects . Objects are represented by a variable name, and are created\nby using the assignment operator \\ -  anumber  - 2 + 2  # We're storing the result of 2+2 in the variable \"anumber\"\nanumber  # This will print the object.\n\n## [1] 4\n\n# Note: The # symbol begins a comment, and everything following a # will not affect your code.  You can also use = instead of \\ - ...  anumber = 9.123\nanumber\n\n## [1] 9.123  but it's better to use \\ - to differentiate between assigning something\nto a variable and other uses of =, which we'll get to later. You can\nthink of the leftwards arrow as storing data  in  the object, rather\nthan just setting a variable equal to some value.", 
            "title": "Objects and the Assignment Operator \\&lt;-"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#object-classes-with-class", 
            "text": "Every object in R has a  class , or a type that describes the content\nand organization of an object.  class(anumber)\n\n## [1] \"numeric\"  Our object 'anumber' is of the class  numeric . There are a few other\nclasses of object in R:  alogical  - TRUE  # This class is called \"logical\", and takes the value TRUE or FALSE\nclass(alogical)\n\n## [1] \"logical\"\n\nacharacter  - \"data is\"  # This class is called \"character\", and holds strings of text\nclass(acharacter)\n\n## [1] \"character\"\n\nafactor  - factor(\"A\")  # This is a class called \"factor\". It's like character, but when elements with the same text are grouped\nclass(afactor)\n\n## [1] \"factor\"  ... plus many other more complex classes, some of which we'll cover\nlater.", 
            "title": "Object Classes with class( )"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#changing-object-classes", 
            "text": "Sometimes you need to change the class of an object. You can  coerce \nsome object classes by using  as.numeric() ,  as.logical() , as.character() ,  as.integer() , and  as.factor() .  a  - \"1\"\nclass(a)\n\n## [1] \"character\"\n\nas.integer(a)\n\n## [1] 1\n\nclass(as.integer(a))\n\n## [1] \"integer\"\n\nb  - 14\nclass(b)\n\n## [1] \"numeric\"\n\nas.character(b)\n\n## [1] \"14\"\n\nclass(as.character(b))\n\n## [1] \"character\"\n\nas.factor(b)\n\n## [1] 14\n## Levels: 14\n\nclass(as.factor(b))\n\n## [1] \"factor\"\n\nc  - 1\nd  - 0\nclass(c)\n\n## [1] \"numeric\"\n\nclass(d)\n\n## [1] \"numeric\"\n\nas.logical(c)\n\n## [1] TRUE\n\nas.logical(d)\n\n## [1] FALSE\n\nclass(as.logical(c))\n\n## [1] \"logical\"\n\nclass(as.logical(d))\n\n## [1] \"logical\"", 
            "title": "Changing object classes"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#combining-things-with-c", 
            "text": "We use  c()  to  combine  or  concatenate   elements  (numbers,\nintegers, logical values, or character strings):  somenumbers  - c(5.234, 3, 10.1, 900)\nsomelogical  - c(TRUE, TRUE, FALSE, TRUE, FALSE)\nsomecharacter  - c(\"Princeton\", \"Yale\", \"Harvard\", \"Penn\")\nsomefactor  - factor(c(\"A\", \"B\", \"C\", \"B\", \"B\", \"A\"))\nsomenumbers\n\n## [1]   5.234   3.000  10.100 900.000\n\nsomelogical\n\n## [1]  TRUE  TRUE FALSE  TRUE FALSE\n\nsomecharacter\n\n## [1] \"Princeton\" \"Yale\"      \"Harvard\"   \"Penn\"\n\nsomefactor\n\n## [1] A B C B B A\n## Levels: A B C  c()  is a  function  that combines various arguments or  elements \nto form a  vector , a one-dimensional series of values.   A function is like a command that takes several  arguments  and\nreturns a result. In R, you call functions with a function name followed\nby a set of parentheses. Inside of the parentheses go what are called\narguments, which indicate various details about how the function should\noperate. In the  c()  function, the arguments of inside the parentheses\nafter the c are the things to be combined.   We've used a few other functions so far.  class()  is a function that\nreturns the class of the object in parentheses.  as.integer()  and the\nother coercion functions change the class of the object in parentheses. factor()  encodes its argument as a factor.   There are many  base  functions in R, i.e. functions that are built-in\nand ready to use. Sometimes, you might need to do something that isn't\neasily done with the base functions. In R, you can install  packages ,\nwhich include additional functions written by other R users. You can\ninstall packages using the  install.packages()  function, and load them\nusing  library() . For example, to install the psych library, use install.packages('psych') .   This code loads the \"psych\" package, which provides some functions that\nare useful for doing statistical analyses of experimental data.  library(psych)", 
            "title": "Combining things with c()"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#tip-help-with-functions", 
            "text": "You can access the help page for a function by using the ? mark. This\nwill show you information about what the function does and which\narguments you can specify. Try typing ?c into the console. ? will try to\naccess the help page for a particular command, while ?? will search the\nhelp pages.", 
            "title": "Tip: Help with functions"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#recap-objects-classes-vectors-functions", 
            "text": "To recap, information we work with in R is stored in  objects . Each\nobject has one or more  class  (or type). Four types of  vectors \n(one dimensional objects) are:   Numeric : numbers with decimal values  Integers : numbers without decimal values  Logical : True or False  Character : strings of text  Factor : strings of text that indicate groups, conditions, etc.   Functions  are commands that execute code, and contain  arguments \nthat detail how to do so.", 
            "title": "Recap: Objects, Classes, Vectors, &amp; Functions"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#dataframes-another-kind-of-object", 
            "text": "A data.frame is another kind of object, where data are stored in a\nmatrix or table-like format. Let's try creating a simple data frame with\none row and three columns for each participant in a research study: \"id\"\ncontains a unique number to identify each participant, \"condition\"\nindicates whether each participant was assigned to condition A or\ncondition B, and \"rt\" is the reaction time in a task.  You'll see some new functions in the code below.  # We use data.frame() to create a new data.frame from scratch.\nmydata  - data.frame(id = seq(1:50),  # create a column named \"id\" with the numbers (sequence) 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\nclass(mydata)\n\n## [1] \"data.frame\"  Now we've created a data.frame with 50 rows and 3 columns. You can\nexamine the first few rows by using the head( ) function:  head(mydata)\n\n##   id condition        rt\n## 1  1         A  99.21827\n## 2  2         B 121.28731\n## 3  3         A 105.02078\n## 4  4         B  97.96730\n## 5  5         A  83.37108\n## 6  6         B 104.58375  You can also view the full data.frame itself by entering \"mydata\", or\nyou can view it in a table by entering  View(mydata)  or clicking on the\nmydata object in the Environment tab in RStudio.  A simple way to summarize data is through the  summary  function:  summary(mydata)\n\n##        id        condition       rt        \n##  Min.   : 1.00   A:25      Min.   : 67.10  \n##  1st Qu.:13.25   B:25      1st Qu.: 85.94  \n##  Median :25.50             Median : 96.99  \n##  Mean   :25.50             Mean   : 97.83  \n##  3rd Qu.:37.75             3rd Qu.:109.23  \n##  Max.   :50.00             Max.   :134.91", 
            "title": "data.frames - Another kind of object"
        }, 
        {
            "location": "/0-getting-started/0c-rbasics/#reading-data-from-a-file", 
            "text": "Often, the data you want to analyze is located in a separate file. To\nwork with it in R, you need to  read  in the data.   There are a few different functions for reading data into R, depending\non the type of data file.  mydata  - read.csv(\"../data/training_long.csv\") # read.csv() is used for Comma Separated Value files\n#mydata  - read.delim() # read.delim() is used when your data are separated/delimited by the TAB character\n#mydata  - read.table()", 
            "title": "Reading data from a file"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/", 
            "text": "Indexing Data\n\n\nIndexing with Brackets\n\n\nYou'll often need to refer to only part of an object, such as a single\nvalue in a vector, or a single row, column, or other portion of a\ndata.frame. In R, you can use brackets [ ] after an object's name to\nselect a \nsubset\n of the object (also called \nindexing\n):\n\n\navector \n- c(3, 6, 9, 12, 15, 18, 21, 24, 27)  # Let's create a vector with 9 elements.\navector # prints the whole object\n\n## [1]  3  6  9 12 15 18 21 24 27\n\navector[4] # prints the fourth element of the vector\n\n## [1] 12\n\navector[4:7] # prints the 4th through 7th elements of the vector\n\n## [1] 12 15 18 21\n\navector[c(4,5,6,7)] # same as the above line\n\n## [1] 12 15 18 21\n\navector[-3]  # drops the third element and prints the rest\n\n## [1]  3  6 12 15 18 21 24 27\n\n\n\n\n\nFor two dimensional objects like data.frames, you enter two numbers in\nthe bracket: the first is the row (or rows) you want to select, and the\nsecond is the column(s):\n\n\n# First, let's recreate our random data.frame:\nmydata \n- data.frame(id = 1:50,  # create a column named \"id\" with the numbers 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\n\nhead(mydata)  # Let's print the head of the data for reference.\n\n##   id condition       rt\n## 1  1         A 97.88828\n## 2  2         B 99.00335\n## 3  3         A 97.12588\n## 4  4         B 95.51779\n## 5  5         A 84.63846\n## 6  6         B 96.83478\n\nmydata[1, 3]  # select a single cell in the first row, third column\n\n## [1] 97.88828\n\n# You'll see from the printout of head(mydata) above that this is the reaction time for participant 1.\n\nmydata[3, ]  # leave one of the numbers blank if you want to select all columns for a given row\n\n##   id condition       rt\n## 3  3         A 97.12588\n\nmydata[, 3]  # or all rows for a given column (rt)\n\n##  [1]  97.88828  99.00335  97.12588  95.51779  84.63846  96.83478 103.15444\n##  [8]  96.55686 124.52415 102.16705  98.67089 132.08099  77.05704 124.99174\n## [15] 114.81214 112.26099  93.98117  74.89734 103.54251 107.38232  86.01469\n## [22]  88.95094  89.04053 110.68045 120.56711 109.06280 119.83549 115.14795\n## [29]  88.94589 101.26912  88.24853 100.86696  96.74147  90.66447 114.76147\n## [36] 100.16092  98.65072  94.58490 113.57770  99.48745  81.45639  91.48639\n## [43]  99.14611 108.31372 120.28770 112.03712 109.07390 104.34280 106.86190\n## [50]  96.97260\n\nmydata[, 'rt']  # also gets the rt column\n\n##  [1]  97.88828  99.00335  97.12588  95.51779  84.63846  96.83478 103.15444\n##  [8]  96.55686 124.52415 102.16705  98.67089 132.08099  77.05704 124.99174\n## [15] 114.81214 112.26099  93.98117  74.89734 103.54251 107.38232  86.01469\n## [22]  88.95094  89.04053 110.68045 120.56711 109.06280 119.83549 115.14795\n## [29]  88.94589 101.26912  88.24853 100.86696  96.74147  90.66447 114.76147\n## [36] 100.16092  98.65072  94.58490 113.57770  99.48745  81.45639  91.48639\n## [43]  99.14611 108.31372 120.28770 112.03712 109.07390 104.34280 106.86190\n## [50]  96.97260\n\nmydata['rt']  # if you don't use a comma, it assumes you want a column\n\n##           rt\n## 1   97.88828\n## 2   99.00335\n## 3   97.12588\n## 4   95.51779\n## 5   84.63846\n## 6   96.83478\n## 7  103.15444\n## 8   96.55686\n## 9  124.52415\n## 10 102.16705\n## 11  98.67089\n## 12 132.08099\n## 13  77.05704\n## 14 124.99174\n## 15 114.81214\n## 16 112.26099\n## 17  93.98117\n## 18  74.89734\n## 19 103.54251\n## 20 107.38232\n## 21  86.01469\n## 22  88.95094\n## 23  89.04053\n## 24 110.68045\n## 25 120.56711\n## 26 109.06280\n## 27 119.83549\n## 28 115.14795\n## 29  88.94589\n## 30 101.26912\n## 31  88.24853\n## 32 100.86696\n## 33  96.74147\n## 34  90.66447\n## 35 114.76147\n## 36 100.16092\n## 37  98.65072\n## 38  94.58490\n## 39 113.57770\n## 40  99.48745\n## 41  81.45639\n## 42  91.48639\n## 43  99.14611\n## 44 108.31372\n## 45 120.28770\n## 46 112.03712\n## 47 109.07390\n## 48 104.34280\n## 49 106.86190\n## 50  96.97260\n\nmydata[1:10, ]  # You can select multiple rows and/or columns. Here, we're selecting the first ten rows, all columns.\n\n##    id condition        rt\n## 1   1         A  97.88828\n## 2   2         B  99.00335\n## 3   3         A  97.12588\n## 4   4         B  95.51779\n## 5   5         A  84.63846\n## 6   6         B  96.83478\n## 7   7         A 103.15444\n## 8   8         B  96.55686\n## 9   9         A 124.52415\n## 10 10         B 102.16705\n\nmydata[c(1, 3, 5),]  # This will select the first, third, and fifth rows, all columns.\n\n##   id condition       rt\n## 1  1         A 97.88828\n## 3  3         A 97.12588\n## 5  5         A 84.63846\n\n\n\n\n\nNote that you always need to include the comma when using brackets to\nsubset a two-dimensional object like a data-frame. If you try mydata[1],\nyou will get an error (because R doesn't know whether you're referring\nto the first row or column)\n\n\n\n\nUsually, your data will have column names (like ours: id, condition, \n\nrt). There is a better way to select and manipulate entire columns of\ndata by referring to the column name. In a data.frame, each column is a\nvector of values, and you can select that vector by calling the name of\nthe data.frame followed by the $ symbol and then the column name:\n\n\nmydata$rt\n\n##  [1]  97.88828  99.00335  97.12588  95.51779  84.63846  96.83478 103.15444\n##  [8]  96.55686 124.52415 102.16705  98.67089 132.08099  77.05704 124.99174\n## [15] 114.81214 112.26099  93.98117  74.89734 103.54251 107.38232  86.01469\n## [22]  88.95094  89.04053 110.68045 120.56711 109.06280 119.83549 115.14795\n## [29]  88.94589 101.26912  88.24853 100.86696  96.74147  90.66447 114.76147\n## [36] 100.16092  98.65072  94.58490 113.57770  99.48745  81.45639  91.48639\n## [43]  99.14611 108.31372 120.28770 112.03712 109.07390 104.34280 106.86190\n## [50]  96.97260\n\nmydata$condition\n\n##  [1] A B A B A B A B A B A B A B A B A B A B A B A B A B A B A B A B A B A\n## [36] B A B A B A B A B A B A B A B\n## Levels: A B\n\n\n\n\n\nBecause each column is a vector, you can use both the dollar sign\nnotation and brackets to select a single value from a single column:\n\n\nmydata$rt[10]\n\n## [1] 102.1671\n\n# is the same as:\nmydata[10, 3]\n\n## [1] 102.1671\n\nmydata[10, 'rt']\n\n## [1] 102.1671\n\n\n\n \n\n\nConditional Indexing\n\n\nSometimes, you need to \nconditionally\n select part of an object - for\nexample, you need only the rows where reaction time is greater than 100.\nYou can use >, \\\n, >=, \\\n=, and == in brackets to do this:\n\n\nmydata[mydata$rt \n 120, ]  # Select rows of mydata where reaction time is greater than 120, all columns\n\n##    id condition       rt\n## 9   9         A 124.5241\n## 12 12         B 132.0810\n## 14 14         B 124.9917\n## 25 25         A 120.5671\n## 45 45         A 120.2877\n\n\n\nHow does this work? Let's see what's going on inside the brackets.\n\n\nmydata$rt \n 120\n\n##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n## [12]  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [23] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [45]  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\n\nThis returns a logical vector with 50 values (one for each row), where\neach value indicates whether each item in the vector mydata$rt is\ngreater than 120. When we include this in the brackets before the comma,\nR will select only the rows where the statement is TRUE.\n\n\n\n\nHere are a few other examples of conditional indexing:\n\n\nmydata[mydata$id \n= 10,]\n\n##    id condition        rt\n## 1   1         A  97.88828\n## 2   2         B  99.00335\n## 3   3         A  97.12588\n## 4   4         B  95.51779\n## 5   5         A  84.63846\n## 6   6         B  96.83478\n## 7   7         A 103.15444\n## 8   8         B  96.55686\n## 9   9         A 124.52415\n## 10 10         B 102.16705\n\nmydata[mydata$condition == \"A\", ]\n\n##    id condition        rt\n## 1   1         A  97.88828\n## 3   3         A  97.12588\n## 5   5         A  84.63846\n## 7   7         A 103.15444\n## 9   9         A 124.52415\n## 11 11         A  98.67089\n## 13 13         A  77.05704\n## 15 15         A 114.81214\n## 17 17         A  93.98117\n## 19 19         A 103.54251\n## 21 21         A  86.01469\n## 23 23         A  89.04053\n## 25 25         A 120.56711\n## 27 27         A 119.83549\n## 29 29         A  88.94589\n## 31 31         A  88.24853\n## 33 33         A  96.74147\n## 35 35         A 114.76147\n## 37 37         A  98.65072\n## 39 39         A 113.57770\n## 41 41         A  81.45639\n## 43 43         A  99.14611\n## 45 45         A 120.28770\n## 47 47         A 109.07390\n## 49 49         A 106.86190\n\n\n\nNotice that in the second example, we use the \"double equals\" sign to\nselect the rows of mydata where condition is A. We use == instead of =\nfor conditional formatting to differentiate it from other uses of the =\nsign. You could read this as \"mydata where condition is equal to A\".\n\n\n \n\n\nBoolean Operators \n Conditional Indexing\n\n\nSometimes, you might need to use multiple conditions to select the data\nyou want. For example, you might need all rows of mydata where reaction\ntime is greater than 100, but less than 110. In R, you use the \n symbol\nto combine conditions when both must be true.\n\n\nmydata[mydata$rt \n 100 \n mydata$rt \n 110, ]  # Select rows of mydata where reaction time is greater than 100 and less than 110, all columns\n\n##    id condition       rt\n## 7   7         A 103.1544\n## 10 10         B 102.1671\n## 19 19         A 103.5425\n## 20 20         B 107.3823\n## 26 26         B 109.0628\n## 30 30         B 101.2691\n## 32 32         B 100.8670\n## 36 36         B 100.1609\n## 44 44         B 108.3137\n## 47 47         A 109.0739\n## 48 48         B 104.3428\n## 49 49         A 106.8619\n\n\n\nYou should use the \n symbol when both conditions must be TRUE in order\nto select the data you need.\n\n\n\n\nYou might need to select part of an object depending on either one of\ntwo conditions. For example, you might need all rows of mydata where\nreaction time is less than 90 OR greater than 130. In R, you use the |\n(pronounced \"or\") symbol to combine conditions when either is true.\n\n\nmydata[mydata$rt \n 90 | mydata$rt \n 130, ]  # Select rows of mydata where rt is less than 90 or greater than 130, all columns\n\n##    id condition        rt\n## 5   5         A  84.63846\n## 12 12         B 132.08099\n## 13 13         A  77.05704\n## 18 18         B  74.89734\n## 21 21         A  86.01469\n## 22 22         B  88.95094\n## 23 23         A  89.04053\n## 29 29         A  88.94589\n## 31 31         A  88.24853\n## 41 41         A  81.45639\n\n\n\n\n\nWhen stringing together many \n and | statements, you can use parentheses\nto control the order of operations. Suppose we need the data for only\nthe first 10 participants with extreme reaction times (\\\n 90 or > 130).\nWe could try:\n\n\nmydata[mydata$id \n= 10 \n mydata$rt \n 90 | mydata$rt \n 130, ]\n\n##    id condition        rt\n## 5   5         A  84.63846\n## 12 12         B 132.08099\n\n\n\nUh oh. We shouldn't have that fourth row, because they aren't one of the\nfirst ten participants. R includes that row because of the last OR\nstatement (the reaction time is > 130). The correct way is:\n\n\nmydata[mydata$id \n= 10 \n (mydata$rt \n 90 | mydata$rt \n 130), ]\n\n##   id condition       rt\n## 5  5         A 84.63846\n\n\n\nThe parentheses make sure that R evaluates the OR parts before the AND\npart.\n\n\n \n\n\nThe \nwith\n and \ntransform\n functions\n\n\nUp to this point, we've accessed columns of a data.frame using the \n$\n\nsign. However, the with function allows us to refer to the columns\ndirectly.\n\n\n# add 100 to first five entries of rt column\nwith(mydata, rt[1:5] + 100)   # add 1 to the rt column\n\n## [1] 197.8883 199.0033 197.1259 195.5178 184.6385\n\n# same thing using dollar sign\nmydata$rt[1:5] + 100\n\n## [1] 197.8883 199.0033 197.1259 195.5178 184.6385\n\n# note that it doesn't change mydata!\nmydata$rt[1:5]     # does not have 100 added to it\n\n## [1] 97.88828 99.00335 97.12588 95.51779 84.63846\n\n\n\nThe \ntransform\n function is similar, but let's you to copy a data.frame,\nand add or modify columns of data.\n\n\nnewdata \n- transform(mydata, high_rt = rt \n 120)\nhead(newdata)    # notice the added high_rt column\n\n##   id condition       rt high_rt\n## 1  1         A 97.88828   FALSE\n## 2  2         B 99.00335   FALSE\n## 3  3         A 97.12588   FALSE\n## 4  4         B 95.51779   FALSE\n## 5  5         A 84.63846   FALSE\n## 6  6         B 96.83478   FALSE\n\nwith(newdata, rt[high_rt])    # we can refer to more than one column\n\n## [1] 124.5241 132.0810 124.9917 120.5671 120.2877\n\n\n\nThe subset( ) function\n\n\nThere are many other ways to subset your data in R, using functions\ninstead of brackets. One alternative is the subset( ) function. The\nsubset function takes at least 2 \narguments\n, the things you include\ninside of the parentheses when calling a function. The first argument is\nthe object to be subsetted, and the second is a logical expression\nindicating which elements or rows to keep.\n\n\nsubset(mydata, rt \n 130) # This selects all rows of mydata where rt \n 130\n\n##    id condition      rt\n## 12 12         B 132.081\n\n\n\nYou can also indicate which columns you'd like to keep in the subset( )\nfunction:\n\n\nsubset(mydata, rt \n 130, c(condition, rt))  # select the condition and rt columns where rt \n 130\n\n##    condition      rt\n## 12         B 132.081\n\n\n\nYou can be more explicit with the arguments if you'd like:\n\n\nsubset(x = mydata, subset = rt \n 130, select = c(condition, rt)) # This is the same as the last example, but noting each argument explicitly\n\n##    condition      rt\n## 12         B 132.081\n\n\n\nIf you don't specify the arguments in this way, R will guess which code\nto pass to which argument.\n\n\n \n \n\n\nSummarizing Data\n\n\nNow you know how to select different columns, rows, and cells of your\ndata. Let's learn some new functions that will help you summarize your\ndata. We'll focus on the reaction time data for our dataset.\n\n\nmean(mydata$rt)  # Gives the mean (average) of RT\n\n## [1] 101.8865\n\nsd(mydata$rt)  # Gives the standard deviation of RT\n\n## [1] 12.5267\n\nmedian(mydata$rt)  # Gives the median value\n\n## [1] 99.82418\n\nmin(mydata$rt)  # Gives the minimum value\n\n## [1] 74.89734\n\nmax(mydata$rt)  # Gives the maximum value\n\n## [1] 132.081\n\n\n\n\n\ntable( ) is another useful function. It counts the frequency of each\nvalue in a vector. For example, if we wanted to check how many\nparticipants we had per condition:\n\n\ntable(mydata$condition)\n\n## \n##  A  B \n## 25 25\n\n\n\nWe can see that there are 25 participants in each condition.\n\n\n \n \n\n\nSome Basic Data Visualization\n\n\nLet's review a few functions that create basic, simple visualizations of\nyour data.\n\n\n\n\nHistograms\n\n\nOne of your first steps in analyzing any data should be to look at the\nhistogram of your dependent variable. How is the data distributed? Is it\nnormal? Is it skewed? Are there any outliers?\n\n\nThe \nhist()\n function is the simplest way to view a histogram of any\nvector.\n\n\nhist(mydata$rt)\n\n\n\n\n\nThe data appear to be more or less normally distributed, without any\nnotable outliers. (This makes sense, since we generated the data by\nsampling randomly from a normal distribution.) You can add some\narguments to the hist( ) function to alter the plot. (Remember, you can\nuse TAB while inside the function's parentheses to see a list of\narguments and what they do.)\n\n\nhist(mydata$rt, breaks = 10)  # breaks supplies the number of breaks in the histogram\n\n\n\n\n\nhist(mydata$rt, breaks = 10, freq = F)  # setting freq = F changes the y-axis to probability density instead of count/frequency\n\n\n\n\n\nhist(mydata$rt, breaks = 10, density = 10)  # density sets the density of shading\n\n\n\n\n\nhist(mydata$rt, breaks = 10, xlab = \"Reaction Time\")  # xlab and ylab change the labels on the X and Y axes.\n\n\n\n\n\n \n\n\nBoxplots\n\n\nA boxplot is a good way to compare the distributions of data across\ngroups or conditions. Here's an example that plots and compares our\nreaction time in conditions A and B.\n\n\nboxplot(mydata$rt ~ mydata$condition, xlab = \"Condition\", ylab = \"Reaction Time\")\n\n\n\n\n\nYou'll notice the new ~ symbol in the code. The ~ symbol is used in R to\nwrite formulas, with the dependent variable in the left and the grouping\nvariable on the right. Here, we're telling R that we want a boxplot of\n\nmydata$rt\n, grouped according to \nmydata$condition\n.\n\n\nThe dark solid line indicates the median value in each group. The top\nand bottom of the boxes are the 75th and 25th percentiles, respectively,\nand the endpoints reflect the range. Here, we see that reaction times\nare similar in conditions A and B (which makes sense, since we randomly\nsampled the data in each condition from the same distribution.)", 
            "title": "Indexing and Summarizing"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#indexing-data", 
            "text": "", 
            "title": "Indexing Data"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#indexing-with-brackets", 
            "text": "You'll often need to refer to only part of an object, such as a single\nvalue in a vector, or a single row, column, or other portion of a\ndata.frame. In R, you can use brackets [ ] after an object's name to\nselect a  subset  of the object (also called  indexing ):  avector  - c(3, 6, 9, 12, 15, 18, 21, 24, 27)  # Let's create a vector with 9 elements.\navector # prints the whole object\n\n## [1]  3  6  9 12 15 18 21 24 27\n\navector[4] # prints the fourth element of the vector\n\n## [1] 12\n\navector[4:7] # prints the 4th through 7th elements of the vector\n\n## [1] 12 15 18 21\n\navector[c(4,5,6,7)] # same as the above line\n\n## [1] 12 15 18 21\n\navector[-3]  # drops the third element and prints the rest\n\n## [1]  3  6 12 15 18 21 24 27   For two dimensional objects like data.frames, you enter two numbers in\nthe bracket: the first is the row (or rows) you want to select, and the\nsecond is the column(s):  # First, let's recreate our random data.frame:\nmydata  - data.frame(id = 1:50,  # create a column named \"id\" with the numbers 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\n\nhead(mydata)  # Let's print the head of the data for reference.\n\n##   id condition       rt\n## 1  1         A 97.88828\n## 2  2         B 99.00335\n## 3  3         A 97.12588\n## 4  4         B 95.51779\n## 5  5         A 84.63846\n## 6  6         B 96.83478\n\nmydata[1, 3]  # select a single cell in the first row, third column\n\n## [1] 97.88828\n\n# You'll see from the printout of head(mydata) above that this is the reaction time for participant 1.\n\nmydata[3, ]  # leave one of the numbers blank if you want to select all columns for a given row\n\n##   id condition       rt\n## 3  3         A 97.12588\n\nmydata[, 3]  # or all rows for a given column (rt)\n\n##  [1]  97.88828  99.00335  97.12588  95.51779  84.63846  96.83478 103.15444\n##  [8]  96.55686 124.52415 102.16705  98.67089 132.08099  77.05704 124.99174\n## [15] 114.81214 112.26099  93.98117  74.89734 103.54251 107.38232  86.01469\n## [22]  88.95094  89.04053 110.68045 120.56711 109.06280 119.83549 115.14795\n## [29]  88.94589 101.26912  88.24853 100.86696  96.74147  90.66447 114.76147\n## [36] 100.16092  98.65072  94.58490 113.57770  99.48745  81.45639  91.48639\n## [43]  99.14611 108.31372 120.28770 112.03712 109.07390 104.34280 106.86190\n## [50]  96.97260\n\nmydata[, 'rt']  # also gets the rt column\n\n##  [1]  97.88828  99.00335  97.12588  95.51779  84.63846  96.83478 103.15444\n##  [8]  96.55686 124.52415 102.16705  98.67089 132.08099  77.05704 124.99174\n## [15] 114.81214 112.26099  93.98117  74.89734 103.54251 107.38232  86.01469\n## [22]  88.95094  89.04053 110.68045 120.56711 109.06280 119.83549 115.14795\n## [29]  88.94589 101.26912  88.24853 100.86696  96.74147  90.66447 114.76147\n## [36] 100.16092  98.65072  94.58490 113.57770  99.48745  81.45639  91.48639\n## [43]  99.14611 108.31372 120.28770 112.03712 109.07390 104.34280 106.86190\n## [50]  96.97260\n\nmydata['rt']  # if you don't use a comma, it assumes you want a column\n\n##           rt\n## 1   97.88828\n## 2   99.00335\n## 3   97.12588\n## 4   95.51779\n## 5   84.63846\n## 6   96.83478\n## 7  103.15444\n## 8   96.55686\n## 9  124.52415\n## 10 102.16705\n## 11  98.67089\n## 12 132.08099\n## 13  77.05704\n## 14 124.99174\n## 15 114.81214\n## 16 112.26099\n## 17  93.98117\n## 18  74.89734\n## 19 103.54251\n## 20 107.38232\n## 21  86.01469\n## 22  88.95094\n## 23  89.04053\n## 24 110.68045\n## 25 120.56711\n## 26 109.06280\n## 27 119.83549\n## 28 115.14795\n## 29  88.94589\n## 30 101.26912\n## 31  88.24853\n## 32 100.86696\n## 33  96.74147\n## 34  90.66447\n## 35 114.76147\n## 36 100.16092\n## 37  98.65072\n## 38  94.58490\n## 39 113.57770\n## 40  99.48745\n## 41  81.45639\n## 42  91.48639\n## 43  99.14611\n## 44 108.31372\n## 45 120.28770\n## 46 112.03712\n## 47 109.07390\n## 48 104.34280\n## 49 106.86190\n## 50  96.97260\n\nmydata[1:10, ]  # You can select multiple rows and/or columns. Here, we're selecting the first ten rows, all columns.\n\n##    id condition        rt\n## 1   1         A  97.88828\n## 2   2         B  99.00335\n## 3   3         A  97.12588\n## 4   4         B  95.51779\n## 5   5         A  84.63846\n## 6   6         B  96.83478\n## 7   7         A 103.15444\n## 8   8         B  96.55686\n## 9   9         A 124.52415\n## 10 10         B 102.16705\n\nmydata[c(1, 3, 5),]  # This will select the first, third, and fifth rows, all columns.\n\n##   id condition       rt\n## 1  1         A 97.88828\n## 3  3         A 97.12588\n## 5  5         A 84.63846   Note that you always need to include the comma when using brackets to\nsubset a two-dimensional object like a data-frame. If you try mydata[1],\nyou will get an error (because R doesn't know whether you're referring\nto the first row or column)   Usually, your data will have column names (like ours: id, condition,  \nrt). There is a better way to select and manipulate entire columns of\ndata by referring to the column name. In a data.frame, each column is a\nvector of values, and you can select that vector by calling the name of\nthe data.frame followed by the $ symbol and then the column name:  mydata$rt\n\n##  [1]  97.88828  99.00335  97.12588  95.51779  84.63846  96.83478 103.15444\n##  [8]  96.55686 124.52415 102.16705  98.67089 132.08099  77.05704 124.99174\n## [15] 114.81214 112.26099  93.98117  74.89734 103.54251 107.38232  86.01469\n## [22]  88.95094  89.04053 110.68045 120.56711 109.06280 119.83549 115.14795\n## [29]  88.94589 101.26912  88.24853 100.86696  96.74147  90.66447 114.76147\n## [36] 100.16092  98.65072  94.58490 113.57770  99.48745  81.45639  91.48639\n## [43]  99.14611 108.31372 120.28770 112.03712 109.07390 104.34280 106.86190\n## [50]  96.97260\n\nmydata$condition\n\n##  [1] A B A B A B A B A B A B A B A B A B A B A B A B A B A B A B A B A B A\n## [36] B A B A B A B A B A B A B A B\n## Levels: A B   Because each column is a vector, you can use both the dollar sign\nnotation and brackets to select a single value from a single column:  mydata$rt[10]\n\n## [1] 102.1671\n\n# is the same as:\nmydata[10, 3]\n\n## [1] 102.1671\n\nmydata[10, 'rt']\n\n## [1] 102.1671", 
            "title": "Indexing with Brackets"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#conditional-indexing", 
            "text": "Sometimes, you need to  conditionally  select part of an object - for\nexample, you need only the rows where reaction time is greater than 100.\nYou can use >, \\ , >=, \\ =, and == in brackets to do this:  mydata[mydata$rt   120, ]  # Select rows of mydata where reaction time is greater than 120, all columns\n\n##    id condition       rt\n## 9   9         A 124.5241\n## 12 12         B 132.0810\n## 14 14         B 124.9917\n## 25 25         A 120.5671\n## 45 45         A 120.2877  How does this work? Let's see what's going on inside the brackets.  mydata$rt   120\n\n##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n## [12]  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [23] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n## [45]  TRUE FALSE FALSE FALSE FALSE FALSE  This returns a logical vector with 50 values (one for each row), where\neach value indicates whether each item in the vector mydata$rt is\ngreater than 120. When we include this in the brackets before the comma,\nR will select only the rows where the statement is TRUE.   Here are a few other examples of conditional indexing:  mydata[mydata$id  = 10,]\n\n##    id condition        rt\n## 1   1         A  97.88828\n## 2   2         B  99.00335\n## 3   3         A  97.12588\n## 4   4         B  95.51779\n## 5   5         A  84.63846\n## 6   6         B  96.83478\n## 7   7         A 103.15444\n## 8   8         B  96.55686\n## 9   9         A 124.52415\n## 10 10         B 102.16705\n\nmydata[mydata$condition == \"A\", ]\n\n##    id condition        rt\n## 1   1         A  97.88828\n## 3   3         A  97.12588\n## 5   5         A  84.63846\n## 7   7         A 103.15444\n## 9   9         A 124.52415\n## 11 11         A  98.67089\n## 13 13         A  77.05704\n## 15 15         A 114.81214\n## 17 17         A  93.98117\n## 19 19         A 103.54251\n## 21 21         A  86.01469\n## 23 23         A  89.04053\n## 25 25         A 120.56711\n## 27 27         A 119.83549\n## 29 29         A  88.94589\n## 31 31         A  88.24853\n## 33 33         A  96.74147\n## 35 35         A 114.76147\n## 37 37         A  98.65072\n## 39 39         A 113.57770\n## 41 41         A  81.45639\n## 43 43         A  99.14611\n## 45 45         A 120.28770\n## 47 47         A 109.07390\n## 49 49         A 106.86190  Notice that in the second example, we use the \"double equals\" sign to\nselect the rows of mydata where condition is A. We use == instead of =\nfor conditional formatting to differentiate it from other uses of the =\nsign. You could read this as \"mydata where condition is equal to A\".", 
            "title": "Conditional Indexing"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#boolean-operators-conditional-indexing", 
            "text": "Sometimes, you might need to use multiple conditions to select the data\nyou want. For example, you might need all rows of mydata where reaction\ntime is greater than 100, but less than 110. In R, you use the   symbol\nto combine conditions when both must be true.  mydata[mydata$rt   100   mydata$rt   110, ]  # Select rows of mydata where reaction time is greater than 100 and less than 110, all columns\n\n##    id condition       rt\n## 7   7         A 103.1544\n## 10 10         B 102.1671\n## 19 19         A 103.5425\n## 20 20         B 107.3823\n## 26 26         B 109.0628\n## 30 30         B 101.2691\n## 32 32         B 100.8670\n## 36 36         B 100.1609\n## 44 44         B 108.3137\n## 47 47         A 109.0739\n## 48 48         B 104.3428\n## 49 49         A 106.8619  You should use the   symbol when both conditions must be TRUE in order\nto select the data you need.   You might need to select part of an object depending on either one of\ntwo conditions. For example, you might need all rows of mydata where\nreaction time is less than 90 OR greater than 130. In R, you use the |\n(pronounced \"or\") symbol to combine conditions when either is true.  mydata[mydata$rt   90 | mydata$rt   130, ]  # Select rows of mydata where rt is less than 90 or greater than 130, all columns\n\n##    id condition        rt\n## 5   5         A  84.63846\n## 12 12         B 132.08099\n## 13 13         A  77.05704\n## 18 18         B  74.89734\n## 21 21         A  86.01469\n## 22 22         B  88.95094\n## 23 23         A  89.04053\n## 29 29         A  88.94589\n## 31 31         A  88.24853\n## 41 41         A  81.45639   When stringing together many   and | statements, you can use parentheses\nto control the order of operations. Suppose we need the data for only\nthe first 10 participants with extreme reaction times (\\  90 or > 130).\nWe could try:  mydata[mydata$id  = 10   mydata$rt   90 | mydata$rt   130, ]\n\n##    id condition        rt\n## 5   5         A  84.63846\n## 12 12         B 132.08099  Uh oh. We shouldn't have that fourth row, because they aren't one of the\nfirst ten participants. R includes that row because of the last OR\nstatement (the reaction time is > 130). The correct way is:  mydata[mydata$id  = 10   (mydata$rt   90 | mydata$rt   130), ]\n\n##   id condition       rt\n## 5  5         A 84.63846  The parentheses make sure that R evaluates the OR parts before the AND\npart.", 
            "title": "Boolean Operators &amp; Conditional Indexing"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#the-with-and-transform-functions", 
            "text": "Up to this point, we've accessed columns of a data.frame using the  $ \nsign. However, the with function allows us to refer to the columns\ndirectly.  # add 100 to first five entries of rt column\nwith(mydata, rt[1:5] + 100)   # add 1 to the rt column\n\n## [1] 197.8883 199.0033 197.1259 195.5178 184.6385\n\n# same thing using dollar sign\nmydata$rt[1:5] + 100\n\n## [1] 197.8883 199.0033 197.1259 195.5178 184.6385\n\n# note that it doesn't change mydata!\nmydata$rt[1:5]     # does not have 100 added to it\n\n## [1] 97.88828 99.00335 97.12588 95.51779 84.63846  The  transform  function is similar, but let's you to copy a data.frame,\nand add or modify columns of data.  newdata  - transform(mydata, high_rt = rt   120)\nhead(newdata)    # notice the added high_rt column\n\n##   id condition       rt high_rt\n## 1  1         A 97.88828   FALSE\n## 2  2         B 99.00335   FALSE\n## 3  3         A 97.12588   FALSE\n## 4  4         B 95.51779   FALSE\n## 5  5         A 84.63846   FALSE\n## 6  6         B 96.83478   FALSE\n\nwith(newdata, rt[high_rt])    # we can refer to more than one column\n\n## [1] 124.5241 132.0810 124.9917 120.5671 120.2877", 
            "title": "The with and transform functions"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#the-subset-function", 
            "text": "There are many other ways to subset your data in R, using functions\ninstead of brackets. One alternative is the subset( ) function. The\nsubset function takes at least 2  arguments , the things you include\ninside of the parentheses when calling a function. The first argument is\nthe object to be subsetted, and the second is a logical expression\nindicating which elements or rows to keep.  subset(mydata, rt   130) # This selects all rows of mydata where rt   130\n\n##    id condition      rt\n## 12 12         B 132.081  You can also indicate which columns you'd like to keep in the subset( )\nfunction:  subset(mydata, rt   130, c(condition, rt))  # select the condition and rt columns where rt   130\n\n##    condition      rt\n## 12         B 132.081  You can be more explicit with the arguments if you'd like:  subset(x = mydata, subset = rt   130, select = c(condition, rt)) # This is the same as the last example, but noting each argument explicitly\n\n##    condition      rt\n## 12         B 132.081  If you don't specify the arguments in this way, R will guess which code\nto pass to which argument.", 
            "title": "The subset( ) function"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#summarizing-data", 
            "text": "Now you know how to select different columns, rows, and cells of your\ndata. Let's learn some new functions that will help you summarize your\ndata. We'll focus on the reaction time data for our dataset.  mean(mydata$rt)  # Gives the mean (average) of RT\n\n## [1] 101.8865\n\nsd(mydata$rt)  # Gives the standard deviation of RT\n\n## [1] 12.5267\n\nmedian(mydata$rt)  # Gives the median value\n\n## [1] 99.82418\n\nmin(mydata$rt)  # Gives the minimum value\n\n## [1] 74.89734\n\nmax(mydata$rt)  # Gives the maximum value\n\n## [1] 132.081   table( ) is another useful function. It counts the frequency of each\nvalue in a vector. For example, if we wanted to check how many\nparticipants we had per condition:  table(mydata$condition)\n\n## \n##  A  B \n## 25 25  We can see that there are 25 participants in each condition.", 
            "title": "Summarizing Data"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#some-basic-data-visualization", 
            "text": "Let's review a few functions that create basic, simple visualizations of\nyour data.", 
            "title": "Some Basic Data Visualization"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#histograms", 
            "text": "One of your first steps in analyzing any data should be to look at the\nhistogram of your dependent variable. How is the data distributed? Is it\nnormal? Is it skewed? Are there any outliers?  The  hist()  function is the simplest way to view a histogram of any\nvector.  hist(mydata$rt)   The data appear to be more or less normally distributed, without any\nnotable outliers. (This makes sense, since we generated the data by\nsampling randomly from a normal distribution.) You can add some\narguments to the hist( ) function to alter the plot. (Remember, you can\nuse TAB while inside the function's parentheses to see a list of\narguments and what they do.)  hist(mydata$rt, breaks = 10)  # breaks supplies the number of breaks in the histogram   hist(mydata$rt, breaks = 10, freq = F)  # setting freq = F changes the y-axis to probability density instead of count/frequency   hist(mydata$rt, breaks = 10, density = 10)  # density sets the density of shading   hist(mydata$rt, breaks = 10, xlab = \"Reaction Time\")  # xlab and ylab change the labels on the X and Y axes.", 
            "title": "Histograms"
        }, 
        {
            "location": "/1-basic-analyses/1a-index-and-summarize/#boxplots", 
            "text": "A boxplot is a good way to compare the distributions of data across\ngroups or conditions. Here's an example that plots and compares our\nreaction time in conditions A and B.  boxplot(mydata$rt ~ mydata$condition, xlab = \"Condition\", ylab = \"Reaction Time\")   You'll notice the new ~ symbol in the code. The ~ symbol is used in R to\nwrite formulas, with the dependent variable in the left and the grouping\nvariable on the right. Here, we're telling R that we want a boxplot of mydata$rt , grouped according to  mydata$condition .  The dark solid line indicates the median value in each group. The top\nand bottom of the boxes are the 75th and 25th percentiles, respectively,\nand the endpoints reflect the range. Here, we see that reaction times\nare similar in conditions A and B (which makes sense, since we randomly\nsampled the data in each condition from the same distribution.)", 
            "title": "Boxplots"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/", 
            "text": "Background\n\n\nThis simulated data is based off of training study run by David Moreau.\nIn this study, he examined which of the following programs would be\nbetter for improving spatial memory:\n\n\n\n\nAerobic exercise (\naer\n) -- basically running on a treadmill.\n\n\nWorking memory training (\nwm\n) -- memorizing locations while doing a\n    distracting task on the computer.\n\n\nSomething he called Designed Sport Training (\ncombo\n), meant to\n    combine spatial memory with consistent exercise.\n\n\n\n\nAs shown in the diagram below, participants were tested on their spatial\nmemory, then assigned to a program for a month. Afterward, their spatial\nmemory was tested again. \n\n\nwm_dat \n- read.csv('../data/training_long.csv')\n\n\n\nThe working memory data set has 60 rows and 5 columns. Below are the\nfirst 5 rows.\n\n\nhead(wm_dat, 5)\n\n  subject session wm_score cond time\n1       1  wm_pre 27.75810   wm  pre\n2       2  wm_pre 29.07929   wm  pre\n3       3  wm_pre 36.23483   wm  pre\n4       4  wm_pre 30.28203   wm  pre\n5       5  wm_pre 30.51715   wm  pre\n\n\n\nNote that the \nsession\n, \ncond\n, and \ntime\n columns are factors.\n\n\nstr(wm_dat)\n\n'data.frame':   60 obs. of  5 variables:\n $ subject : int  1 2 3 4 5 6 7 8 9 10 ...\n $ session : Factor w/ 6 levels \"aer_post\",\"aer_pre\",..: 6 6 6 6 6 6 6 6 6 6 ...\n $ wm_score: num  27.8 29.1 36.2 30.3 30.5 ...\n $ cond    : Factor w/ 3 levels \"aer\",\"combo\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ time    : Factor w/ 2 levels \"post\",\"pre\": 2 2 2 2 2 2 2 2 2 2 ...\n\n\n\nThe levels of each factor are..\n\n\n\n\nsession\n: aer_post, aer_pre, combo_post, combo_pre, wm_post,\n    wm_pre\n\n\ncond\n: aer, combo, wm\n\n\ntime\n: post, pre\n\n\n\n\nNote that session is just another way of expressing cond and time\ntogether\n. That is, \nsession\n is the same as..\n\n\npaste(wm_dat$cond, wm_dat$time, sep=\"_\")\n\n [1] \"wm_pre\"     \"wm_pre\"     \"wm_pre\"     \"wm_pre\"     \"wm_pre\"    \n [6] \"wm_pre\"     \"wm_pre\"     \"wm_pre\"     \"wm_pre\"     \"wm_pre\"    \n[11] \"aer_pre\"    \"aer_pre\"    \"aer_pre\"    \"aer_pre\"    \"aer_pre\"   \n[16] \"aer_pre\"    \"aer_pre\"    \"aer_pre\"    \"aer_pre\"    \"aer_pre\"   \n[21] \"combo_pre\"  \"combo_pre\"  \"combo_pre\"  \"combo_pre\"  \"combo_pre\" \n[26] \"combo_pre\"  \"combo_pre\"  \"combo_pre\"  \"combo_pre\"  \"combo_pre\" \n[31] \"wm_post\"    \"wm_post\"    \"wm_post\"    \"wm_post\"    \"wm_post\"   \n[36] \"wm_post\"    \"wm_post\"    \"wm_post\"    \"wm_post\"    \"wm_post\"   \n[41] \"aer_post\"   \"aer_post\"   \"aer_post\"   \"aer_post\"   \"aer_post\"  \n[46] \"aer_post\"   \"aer_post\"   \"aer_post\"   \"aer_post\"   \"aer_post\"  \n[51] \"combo_post\" \"combo_post\" \"combo_post\" \"combo_post\" \"combo_post\"\n[56] \"combo_post\" \"combo_post\" \"combo_post\" \"combo_post\" \"combo_post\"\n\n\n\nAnalyses\n\n\nWhat is the data argument?\n\n\nNote that just like the \nwith\n function, many functions like \nboxplot\n\nhave an argument to let your refer directly to columns of data without\nusing the \n$\n character. This is done using the \ndata\n argument\n\n\nWhat are R formulas?\n\n\nFormulas in R are created using the \n~\n character. The formula \nA ~ B\n\nis best read as \"A by B\". In addition, formula \nA ~ B + C\n can be read\nas \"A by B \nand C\n\". This is well illustrated by the \nboxplot\n\nfunction.\n\n\nBoxplots\n\n\nboxplot(wm_score ~ session, data=wm_dat)   # wm scores by session\n\n\n\n\n\n# if you want, the line below is equivalent\n# boxplot(data=wm_dat, wm_score ~ session)\n\n\n\nHowever, as noted above the \nsession\n column is a combination of \ncond\n\n\nand\n \ntime\n. We can use the \n+\n sign in a formula to make the same\nplot with these columns.\n\n\nboxplot(wm_score ~ time + cond, data=wm_dat)     # wm scores by cond and time\n\n\n\n\n\nIt's a little annoying that the post- and pre-test measures are\nalternating in the plot.\n\n\nDescriptives\n\n\nlibrary(psych)\ndescript \n- describeBy(wm_dat$wm_score, group=wm_dat$session, mat = TRUE, digits=1)\ndescript\n\n   item     group1 vars  n mean  sd median trimmed mad  min  max range\n11    1   aer_post    1 10 41.0 4.3   39.8    40.5 3.6 35.9 49.7  13.7\n12    2    aer_pre    1 10 30.8 4.2   31.5    31.1 3.5 22.1 37.1  15.0\n13    3 combo_post    1 10 45.9 3.4   45.7    46.1 1.8 38.8 51.1  12.3\n14    4  combo_pre    1 10 28.3 3.7   27.3    28.1 2.7 23.3 35.0  11.8\n15    5    wm_post    1 10 41.3 2.1   42.0    41.4 2.4 38.5 43.6   5.1\n16    6     wm_pre    1 10 30.3 3.8   29.7    30.1 3.0 24.9 36.9  11.9\n   skew kurtosis  se\n11  0.7     -0.9 1.4\n12 -0.5     -0.4 1.3\n13 -0.3     -0.3 1.1\n14  0.5     -1.2 1.2\n15 -0.2     -1.9 0.7\n16  0.5     -1.1 1.2\n\n\n\nNote that the post scores seem to differ between conditions:\n\n\ndescript[c(1,3,5), c('group1', 'mean', 'se')]\n\n       group1 mean  se\n11   aer_post 41.0 1.4\n13 combo_post 45.9 1.1\n15    wm_post 41.3 0.7\n\n\n\nANOVA\n\n\nAssuming all of the pre-test scores were the same, we will just consider\nthe post-test scores. The \naov\n function let's use test whether the mean\nscores on the post-test were the same for all conditions.\n\n\nIn terms of formulas we should say, \"do \nwm_score\n means differ by\n\ncond\n\".\n\n\npost \n- subset(wm_dat, time == \"post\")\nfit \n- aov(wm_score ~ cond, data=post)\nreport \n- anova(fit)\nreport\n\nAnalysis of Variance Table\n\nResponse: wm_score\n          Df Sum Sq Mean Sq F value   Pr(\nF)   \ncond       2 151.58  75.789  6.5084 0.004933 **\nResiduals 27 314.41  11.645                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nThe p-value is 0.0049, so there is strong evidence that the means are\n\nnot\n equal.\n\n\nWe can use \nTukey's Honestly Significant\nDifferences\n\nprocedure to test exactly which means are different from each other.\nThis procedure tries to take into account the number of tests we've\nperformed, in order to control the \nFamily Wise Error\nRate\n.\n\n\ntuk \n- TukeyHSD(fit)\ntuk\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = wm_score ~ cond, data = post)\n\n$cond\n                diff       lwr       upr     p adj\ncombo-aer  4.9216061  1.137791  8.705421 0.0089245\nwm-aer     0.3230403 -3.460774  4.106855 0.9756233\nwm-combo  -4.5985658 -8.382381 -0.814751 0.0148740\n\n\n\nEach row is a test. For example, the first row tests whether the combo\nand aerobic means differed from eachother, and there is strong evidence\n(p = 0.0089245). Overall, it appears there's strong evidence that\nparticipants in the combo condition did better than the other two.\n\n\nThe test that Tukey's HSD is modifying is called a\n\nt-test\n. We can run\nit directly using the \nt.test\n function..\n\n\npost_wm_combo \n- subset(wm_dat, time == \"post\" \n cond %in% c('wm', 'combo'))\n# notice that we use the same formula as the anova\nt.test(wm_score ~ session, data=post_wm_combo)\n\n\n    Welch Two Sample t-test\n\ndata:  wm_score by session\nt = 3.6147, df = 14.966, p-value = 0.002556\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 1.886415 7.310716\nsample estimates:\nmean in group combo_post    mean in group wm_post \n                45.88674                 41.28818\n\n\n\nReferences\n\n\n\n\nstack overflow post on rounding\n    output\n\n\nQuick-R anova page\n\n\nmodel formulas for\n    regression", 
            "title": "t-tests and ANOVA"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/#background", 
            "text": "This simulated data is based off of training study run by David Moreau.\nIn this study, he examined which of the following programs would be\nbetter for improving spatial memory:   Aerobic exercise ( aer ) -- basically running on a treadmill.  Working memory training ( wm ) -- memorizing locations while doing a\n    distracting task on the computer.  Something he called Designed Sport Training ( combo ), meant to\n    combine spatial memory with consistent exercise.   As shown in the diagram below, participants were tested on their spatial\nmemory, then assigned to a program for a month. Afterward, their spatial\nmemory was tested again.   wm_dat  - read.csv('../data/training_long.csv')  The working memory data set has 60 rows and 5 columns. Below are the\nfirst 5 rows.  head(wm_dat, 5)\n\n  subject session wm_score cond time\n1       1  wm_pre 27.75810   wm  pre\n2       2  wm_pre 29.07929   wm  pre\n3       3  wm_pre 36.23483   wm  pre\n4       4  wm_pre 30.28203   wm  pre\n5       5  wm_pre 30.51715   wm  pre  Note that the  session ,  cond , and  time  columns are factors.  str(wm_dat)\n\n'data.frame':   60 obs. of  5 variables:\n $ subject : int  1 2 3 4 5 6 7 8 9 10 ...\n $ session : Factor w/ 6 levels \"aer_post\",\"aer_pre\",..: 6 6 6 6 6 6 6 6 6 6 ...\n $ wm_score: num  27.8 29.1 36.2 30.3 30.5 ...\n $ cond    : Factor w/ 3 levels \"aer\",\"combo\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ time    : Factor w/ 2 levels \"post\",\"pre\": 2 2 2 2 2 2 2 2 2 2 ...  The levels of each factor are..   session : aer_post, aer_pre, combo_post, combo_pre, wm_post,\n    wm_pre  cond : aer, combo, wm  time : post, pre   Note that session is just another way of expressing cond and time\ntogether . That is,  session  is the same as..  paste(wm_dat$cond, wm_dat$time, sep=\"_\")\n\n [1] \"wm_pre\"     \"wm_pre\"     \"wm_pre\"     \"wm_pre\"     \"wm_pre\"    \n [6] \"wm_pre\"     \"wm_pre\"     \"wm_pre\"     \"wm_pre\"     \"wm_pre\"    \n[11] \"aer_pre\"    \"aer_pre\"    \"aer_pre\"    \"aer_pre\"    \"aer_pre\"   \n[16] \"aer_pre\"    \"aer_pre\"    \"aer_pre\"    \"aer_pre\"    \"aer_pre\"   \n[21] \"combo_pre\"  \"combo_pre\"  \"combo_pre\"  \"combo_pre\"  \"combo_pre\" \n[26] \"combo_pre\"  \"combo_pre\"  \"combo_pre\"  \"combo_pre\"  \"combo_pre\" \n[31] \"wm_post\"    \"wm_post\"    \"wm_post\"    \"wm_post\"    \"wm_post\"   \n[36] \"wm_post\"    \"wm_post\"    \"wm_post\"    \"wm_post\"    \"wm_post\"   \n[41] \"aer_post\"   \"aer_post\"   \"aer_post\"   \"aer_post\"   \"aer_post\"  \n[46] \"aer_post\"   \"aer_post\"   \"aer_post\"   \"aer_post\"   \"aer_post\"  \n[51] \"combo_post\" \"combo_post\" \"combo_post\" \"combo_post\" \"combo_post\"\n[56] \"combo_post\" \"combo_post\" \"combo_post\" \"combo_post\" \"combo_post\"", 
            "title": "Background"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/#analyses", 
            "text": "", 
            "title": "Analyses"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/#what-is-the-data-argument", 
            "text": "Note that just like the  with  function, many functions like  boxplot \nhave an argument to let your refer directly to columns of data without\nusing the  $  character. This is done using the  data  argument", 
            "title": "What is the data argument?"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/#what-are-r-formulas", 
            "text": "Formulas in R are created using the  ~  character. The formula  A ~ B \nis best read as \"A by B\". In addition, formula  A ~ B + C  can be read\nas \"A by B  and C \". This is well illustrated by the  boxplot \nfunction.", 
            "title": "What are R formulas?"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/#boxplots", 
            "text": "boxplot(wm_score ~ session, data=wm_dat)   # wm scores by session   # if you want, the line below is equivalent\n# boxplot(data=wm_dat, wm_score ~ session)  However, as noted above the  session  column is a combination of  cond  and   time . We can use the  +  sign in a formula to make the same\nplot with these columns.  boxplot(wm_score ~ time + cond, data=wm_dat)     # wm scores by cond and time   It's a little annoying that the post- and pre-test measures are\nalternating in the plot.", 
            "title": "Boxplots"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/#descriptives", 
            "text": "library(psych)\ndescript  - describeBy(wm_dat$wm_score, group=wm_dat$session, mat = TRUE, digits=1)\ndescript\n\n   item     group1 vars  n mean  sd median trimmed mad  min  max range\n11    1   aer_post    1 10 41.0 4.3   39.8    40.5 3.6 35.9 49.7  13.7\n12    2    aer_pre    1 10 30.8 4.2   31.5    31.1 3.5 22.1 37.1  15.0\n13    3 combo_post    1 10 45.9 3.4   45.7    46.1 1.8 38.8 51.1  12.3\n14    4  combo_pre    1 10 28.3 3.7   27.3    28.1 2.7 23.3 35.0  11.8\n15    5    wm_post    1 10 41.3 2.1   42.0    41.4 2.4 38.5 43.6   5.1\n16    6     wm_pre    1 10 30.3 3.8   29.7    30.1 3.0 24.9 36.9  11.9\n   skew kurtosis  se\n11  0.7     -0.9 1.4\n12 -0.5     -0.4 1.3\n13 -0.3     -0.3 1.1\n14  0.5     -1.2 1.2\n15 -0.2     -1.9 0.7\n16  0.5     -1.1 1.2  Note that the post scores seem to differ between conditions:  descript[c(1,3,5), c('group1', 'mean', 'se')]\n\n       group1 mean  se\n11   aer_post 41.0 1.4\n13 combo_post 45.9 1.1\n15    wm_post 41.3 0.7", 
            "title": "Descriptives"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/#anova", 
            "text": "Assuming all of the pre-test scores were the same, we will just consider\nthe post-test scores. The  aov  function let's use test whether the mean\nscores on the post-test were the same for all conditions.  In terms of formulas we should say, \"do  wm_score  means differ by cond \".  post  - subset(wm_dat, time == \"post\")\nfit  - aov(wm_score ~ cond, data=post)\nreport  - anova(fit)\nreport\n\nAnalysis of Variance Table\n\nResponse: wm_score\n          Df Sum Sq Mean Sq F value   Pr( F)   \ncond       2 151.58  75.789  6.5084 0.004933 **\nResiduals 27 314.41  11.645                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  The p-value is 0.0049, so there is strong evidence that the means are not  equal.  We can use  Tukey's Honestly Significant\nDifferences \nprocedure to test exactly which means are different from each other.\nThis procedure tries to take into account the number of tests we've\nperformed, in order to control the  Family Wise Error\nRate .  tuk  - TukeyHSD(fit)\ntuk\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = wm_score ~ cond, data = post)\n\n$cond\n                diff       lwr       upr     p adj\ncombo-aer  4.9216061  1.137791  8.705421 0.0089245\nwm-aer     0.3230403 -3.460774  4.106855 0.9756233\nwm-combo  -4.5985658 -8.382381 -0.814751 0.0148740  Each row is a test. For example, the first row tests whether the combo\nand aerobic means differed from eachother, and there is strong evidence\n(p = 0.0089245). Overall, it appears there's strong evidence that\nparticipants in the combo condition did better than the other two.  The test that Tukey's HSD is modifying is called a t-test . We can run\nit directly using the  t.test  function..  post_wm_combo  - subset(wm_dat, time == \"post\"   cond %in% c('wm', 'combo'))\n# notice that we use the same formula as the anova\nt.test(wm_score ~ session, data=post_wm_combo)\n\n\n    Welch Two Sample t-test\n\ndata:  wm_score by session\nt = 3.6147, df = 14.966, p-value = 0.002556\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 1.886415 7.310716\nsample estimates:\nmean in group combo_post    mean in group wm_post \n                45.88674                 41.28818", 
            "title": "ANOVA"
        }, 
        {
            "location": "/1-basic-analyses/1b-t-tests-and-anova/#references", 
            "text": "stack overflow post on rounding\n    output  Quick-R anova page  model formulas for\n    regression", 
            "title": "References"
        }, 
        {
            "location": "/1-basic-analyses/1c-visualization/", 
            "text": "Data Visualization with \nggplot2\n\n\nggplot2\n is a package for plotting data. The \"gg\" stands for \"grammar\nof graphics\". To use \nggplot2\n, first you must load the package (after\ninstalling).\n\n\nlibrary(ggplot2)\n\n## \n## Attaching package: 'ggplot2'\n## \n## The following objects are masked from 'package:psych':\n## \n##     %+%, alpha\n\n\n\n \n\n\nThe code for creating a plot using ggplot is more complicated than using\n\nboxplot()\n or \nhist()\n. Here's an example that we'll walk through step\nby step:\n\n\n# We're going to use the 'describe' function from the psych package, so first load it:\nlibrary(psych)\n\n# Let's create a random data set with 50 observations of reaction time in two conditions.\nmydata \n- data.frame(id = seq(1:50),  # create a column named \"id\" with the numbers (sequence) 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\n\n# Now, get the mean and standard error for each condition\nmydata.summary \n- describeBy(mydata, \"condition\")\nmydata.summary\n\n## group: A\n##            vars  n   mean    sd median trimmed   mad   min    max range\n## id            1 25  25.00 14.72   25.0   25.00 17.79  1.00  49.00 48.00\n## condition*    2 25   1.00  0.00    1.0    1.00  0.00  1.00   1.00  0.00\n## rt            3 25 100.25 13.48  100.4  100.28 12.13 70.92 131.17 60.25\n##            skew kurtosis   se\n## id         0.00    -1.34 2.94\n## condition*  NaN      NaN 0.00\n## rt         0.03    -0.26 2.70\n## -------------------------------------------------------- \n## group: B\n##            vars  n  mean    sd median trimmed   mad   min    max range\n## id            1 25 26.00 14.72  26.00   26.00 17.79  2.00  50.00 48.00\n## condition*    2 25  2.00  0.00   2.00    2.00  0.00  2.00   2.00  0.00\n## rt            3 25 99.54 13.56 101.84  100.35 11.91 59.77 126.83 67.07\n##             skew kurtosis   se\n## id          0.00    -1.34 2.94\n## condition*   NaN      NaN 0.00\n## rt         -0.74     1.11 2.71\n\nmydata.plot \n- data.frame(condition = factor(c(\"A\", \"B\")),\n                          meanRT = c(mydata.summary[[1]]$mean[3], mydata.summary[[2]]$mean[3]),\n                          se = c(mydata.summary[[1]]$se[3], mydata.summary[[2]]$se[3]))\n\nggplot(mydata.plot, aes(x = condition, y = meanRT)) +\n  geom_bar(stat= \"identity\", width = .5) +\n  geom_errorbar(aes(ymin = meanRT - se, ymax = meanRT + se), width = .25)\n\n\n\n\n\n \n\n\nLet's go through the code step by step.\n\n\n\n\nFirst, we load the \npsych\n package and create our data.frame.\n\n\n# We're going to use the 'describe' function from the psych package, so first load it:\nlibrary(psych)\n\n# Let's create a random data set with 50 observations of reaction time in two conditions.\nmydata \n- data.frame(id = seq(1:50),  # create a column named \"id\" with the numbers (sequence) 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\n\n\n\nThen, we must calculate the mean reaction time and standard error of\nreaction time for each condition.\n\n\nmydata.summary \n- describeBy(mydata, \"condition\")\nmydata.summary\n\n## group: A\n##            vars  n   mean    sd median trimmed   mad   min    max range\n## id            1 25  25.00 14.72   25.0   25.00 17.79  1.00  49.00 48.00\n## condition*    2 25   1.00  0.00    1.0    1.00  0.00  1.00   1.00  0.00\n## rt            3 25 100.25 13.48  100.4  100.28 12.13 70.92 131.17 60.25\n##            skew kurtosis   se\n## id         0.00    -1.34 2.94\n## condition*  NaN      NaN 0.00\n## rt         0.03    -0.26 2.70\n## -------------------------------------------------------- \n## group: B\n##            vars  n  mean    sd median trimmed   mad   min    max range\n## id            1 25 26.00 14.72  26.00   26.00 17.79  2.00  50.00 48.00\n## condition*    2 25  2.00  0.00   2.00    2.00  0.00  2.00   2.00  0.00\n## rt            3 25 99.54 13.56 101.84  100.35 11.91 59.77 126.83 67.07\n##             skew kurtosis   se\n## id          0.00    -1.34 2.94\n## condition*   NaN      NaN 0.00\n## rt         -0.74     1.11 2.71\n\n\n\nThe \ndescribeBy\n function calculates a bunch of summary statistics for\nour data.frame, and does it separately for each condition. The result is\ntwo tables, one for each condition.\n\n\n\n\nWe need to store the mean and standard error for the reaction time data\nin each condition. That's what the next 3 lines of code do:\n\n\nmydata.plot \n- data.frame(\n\n\n\nWe're going to store what we need in a data.frame called \"mydata.plot\"\n\n\ncondition = factor(c(\"A\", \"B\")),\n\n\n\nThe first column lists the two conditions, A and B. (Our data.frame will\nhave 2 rows.)\n\n\nmeanRT = c(mydata.summary[[1]]$mean[3], mydata.summary[[2]]$mean[3]),\n\n\n\nWe're combining two things and storing them in a column named \"meanRT\".\nWhat do all of those brackets and numbers mean?\n\n\n\n\nThe mydata.summary object, which was created by the describeBy function,\nis a special type of class called a List. Lists are like vectors, only\ninstead of each element storing a single value, you can store many\nobjects in a list - for example, more than one data.frame.\n\n\n\n\nJust like with vectors, we can index lists using brackets:\n\n\nmydata.summary[1]\n\n## $A\n##            vars  n   mean    sd median trimmed   mad   min    max range\n## id            1 25  25.00 14.72   25.0   25.00 17.79  1.00  49.00 48.00\n## condition*    2 25   1.00  0.00    1.0    1.00  0.00  1.00   1.00  0.00\n## rt            3 25 100.25 13.48  100.4  100.28 12.13 70.92 131.17 60.25\n##            skew kurtosis   se\n## id         0.00    -1.34 2.94\n## condition*  NaN      NaN 0.00\n## rt         0.03    -0.26 2.70\n\nclass(mydata.summary[1])\n\n## [1] \"list\"\n\n\n\nUsing a single set of brackets will let us select the first item in the\nlist, but it's still of the class 'list'. It would be great if we could\ntreat that table as a data.frame, so that we can work with it using the\nother things we know. That's exactly what the double set of brackets\ndoes:\n\n\nmydata.summary[[1]]\n\n##            vars  n   mean    sd median trimmed   mad   min    max range\n## id            1 25  25.00 14.72   25.0   25.00 17.79  1.00  49.00 48.00\n## condition*    2 25   1.00  0.00    1.0    1.00  0.00  1.00   1.00  0.00\n## rt            3 25 100.25 13.48  100.4  100.28 12.13 70.92 131.17 60.25\n##            skew kurtosis   se\n## id         0.00    -1.34 2.94\n## condition*  NaN      NaN 0.00\n## rt         0.03    -0.26 2.70\n\nclass(mydata.summary[[1]])\n\n## [1] \"psych\"      \"describe\"   \"data.frame\"\n\n\n\nYou'll see that the resulting object has three classes - \"psych\",\n\"describe\", and most useful for us, \"data.frame\". Now, we can use the $\nsymbol to select a column by name.\n\n\nmydata.summary[[1]]$mean\n\n## [1]  25.0000   1.0000 100.2517\n\n\n\nThis selects the column of means for condition A. We're interested in\nonly the mean reaction time, so we can again use brackets to select the\nthird element:\n\n\nmydata.summary[[1]]$mean[3]\n\n## [1] 100.2517\n\n\n\nThis code says to select the third element of the column named \"mean\" of\nthe content of the first item in the list \"mydata.summary\".\n\n\n\n\nNow, we can change the 1 to a 2 to select the mean reaction time for\ncondition B, and combine them using \nc()\n.\n\n\nc(mydata.summary[[1]]$mean[3], mydata.summary[[2]]$mean[3])\n\n## [1] 100.25170  99.54173\n\n\n\nWe store the result in a column of our new data.frame named \"meanRT\". We\ncan do the exact same thing to select the standard error (se) of\nreaction time for each condition:\n\n\nse = c(mydata.summary[[1]]$se[3], mydata.summary[[2]]$se[3]))\n\n\n\nWe end up with a data.frame that has two rows and three columns:\n\n\nmydata.plot\n\n##   condition    meanRT       se\n## 1         A 100.25170 2.696155\n## 2         B  99.54173 2.712388\n\n\n\n\n\nNow let's break down the ggplot code:\n\n\nggplot(mydata.plot, aes(x = condition, y = meanRT)) +\n\n\n\nThe \nggplot()\n function creates an object of the class \"ggplot\". Here,\nwe give it two arguments. The first tells it the name of our data.frame\n(mydata.plot), and the second tells it how to arrange the data on the x\nand y axes. We want two columns representing our conditions arranged\nalong the x-axis, and the height of the bars to correspond to the mean\nreaction time in each condition. We use \naes()\n to indicate this (it\nstands for \naesthetic mapping\n).\n\n\n\n\nWe've created a ggplot object with condition on the x-axis and mean\nreaction time in the y-axis, but we haven't specified what type of plot\nwe want - a bar plot? Line plot? Something else? So, we add more to the\nggplot object with the plus sign.\n\n\ngeom_bar(stat= \"identity\", width = .5) +\n\n\n\ngeom_bar()\n indicates that we want a bar plot. We provide two\narguments: \nstat = \"identity\"\n indicates that the height of the bars\nshould be exactly what's in the meanRT column, and \nwidth = .5\n sets the\nwidth of the bars to 50% of the default width.\n\n\ngeom_errorbar(aes(ymin = meanRT - se, ymax = meanRT + se), width = .25)\n\n\n\nAnd finally, we add another line to add errorbars to the plot using the\n\ngeom_errorbar()\n function. Importantly, we need to specify how wide the\nbars should be using the \naes()\n argument. Inside \naes()\n, we set the\nminimum y-value for the bars to be the mean minus the standard error\n(meanRT - se), and the maximum y-value to be the mean plus the standard\nerror (meanRT + se). We can also set the width using another argument.\n\n\n \n\n\nggplot2\n can make many other complex visualizations. You can read more\nabout how to use it at \nhttp://docs.ggplot2.org/current/", 
            "title": "plotting with ggplot"
        }, 
        {
            "location": "/1-basic-analyses/1c-visualization/#data-visualization-with-ggplot2", 
            "text": "ggplot2  is a package for plotting data. The \"gg\" stands for \"grammar\nof graphics\". To use  ggplot2 , first you must load the package (after\ninstalling).  library(ggplot2)\n\n## \n## Attaching package: 'ggplot2'\n## \n## The following objects are masked from 'package:psych':\n## \n##     %+%, alpha     The code for creating a plot using ggplot is more complicated than using boxplot()  or  hist() . Here's an example that we'll walk through step\nby step:  # We're going to use the 'describe' function from the psych package, so first load it:\nlibrary(psych)\n\n# Let's create a random data set with 50 observations of reaction time in two conditions.\nmydata  - data.frame(id = seq(1:50),  # create a column named \"id\" with the numbers (sequence) 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data\n\n# Now, get the mean and standard error for each condition\nmydata.summary  - describeBy(mydata, \"condition\")\nmydata.summary\n\n## group: A\n##            vars  n   mean    sd median trimmed   mad   min    max range\n## id            1 25  25.00 14.72   25.0   25.00 17.79  1.00  49.00 48.00\n## condition*    2 25   1.00  0.00    1.0    1.00  0.00  1.00   1.00  0.00\n## rt            3 25 100.25 13.48  100.4  100.28 12.13 70.92 131.17 60.25\n##            skew kurtosis   se\n## id         0.00    -1.34 2.94\n## condition*  NaN      NaN 0.00\n## rt         0.03    -0.26 2.70\n## -------------------------------------------------------- \n## group: B\n##            vars  n  mean    sd median trimmed   mad   min    max range\n## id            1 25 26.00 14.72  26.00   26.00 17.79  2.00  50.00 48.00\n## condition*    2 25  2.00  0.00   2.00    2.00  0.00  2.00   2.00  0.00\n## rt            3 25 99.54 13.56 101.84  100.35 11.91 59.77 126.83 67.07\n##             skew kurtosis   se\n## id          0.00    -1.34 2.94\n## condition*   NaN      NaN 0.00\n## rt         -0.74     1.11 2.71\n\nmydata.plot  - data.frame(condition = factor(c(\"A\", \"B\")),\n                          meanRT = c(mydata.summary[[1]]$mean[3], mydata.summary[[2]]$mean[3]),\n                          se = c(mydata.summary[[1]]$se[3], mydata.summary[[2]]$se[3]))\n\nggplot(mydata.plot, aes(x = condition, y = meanRT)) +\n  geom_bar(stat= \"identity\", width = .5) +\n  geom_errorbar(aes(ymin = meanRT - se, ymax = meanRT + se), width = .25)      Let's go through the code step by step.   First, we load the  psych  package and create our data.frame.  # We're going to use the 'describe' function from the psych package, so first load it:\nlibrary(psych)\n\n# Let's create a random data set with 50 observations of reaction time in two conditions.\nmydata  - data.frame(id = seq(1:50),  # create a column named \"id\" with the numbers (sequence) 1 through 50\n                     condition = rep(c(\"A\", \"B\"), 25),  # create a \"condition\" column with A and B repeating\n                     rt = rnorm(n = 50, mean = 100, sd = 15))  # create a third column named \"rt\" with randomly generated data  Then, we must calculate the mean reaction time and standard error of\nreaction time for each condition.  mydata.summary  - describeBy(mydata, \"condition\")\nmydata.summary\n\n## group: A\n##            vars  n   mean    sd median trimmed   mad   min    max range\n## id            1 25  25.00 14.72   25.0   25.00 17.79  1.00  49.00 48.00\n## condition*    2 25   1.00  0.00    1.0    1.00  0.00  1.00   1.00  0.00\n## rt            3 25 100.25 13.48  100.4  100.28 12.13 70.92 131.17 60.25\n##            skew kurtosis   se\n## id         0.00    -1.34 2.94\n## condition*  NaN      NaN 0.00\n## rt         0.03    -0.26 2.70\n## -------------------------------------------------------- \n## group: B\n##            vars  n  mean    sd median trimmed   mad   min    max range\n## id            1 25 26.00 14.72  26.00   26.00 17.79  2.00  50.00 48.00\n## condition*    2 25  2.00  0.00   2.00    2.00  0.00  2.00   2.00  0.00\n## rt            3 25 99.54 13.56 101.84  100.35 11.91 59.77 126.83 67.07\n##             skew kurtosis   se\n## id          0.00    -1.34 2.94\n## condition*   NaN      NaN 0.00\n## rt         -0.74     1.11 2.71  The  describeBy  function calculates a bunch of summary statistics for\nour data.frame, and does it separately for each condition. The result is\ntwo tables, one for each condition.   We need to store the mean and standard error for the reaction time data\nin each condition. That's what the next 3 lines of code do:  mydata.plot  - data.frame(  We're going to store what we need in a data.frame called \"mydata.plot\"  condition = factor(c(\"A\", \"B\")),  The first column lists the two conditions, A and B. (Our data.frame will\nhave 2 rows.)  meanRT = c(mydata.summary[[1]]$mean[3], mydata.summary[[2]]$mean[3]),  We're combining two things and storing them in a column named \"meanRT\".\nWhat do all of those brackets and numbers mean?   The mydata.summary object, which was created by the describeBy function,\nis a special type of class called a List. Lists are like vectors, only\ninstead of each element storing a single value, you can store many\nobjects in a list - for example, more than one data.frame.   Just like with vectors, we can index lists using brackets:  mydata.summary[1]\n\n## $A\n##            vars  n   mean    sd median trimmed   mad   min    max range\n## id            1 25  25.00 14.72   25.0   25.00 17.79  1.00  49.00 48.00\n## condition*    2 25   1.00  0.00    1.0    1.00  0.00  1.00   1.00  0.00\n## rt            3 25 100.25 13.48  100.4  100.28 12.13 70.92 131.17 60.25\n##            skew kurtosis   se\n## id         0.00    -1.34 2.94\n## condition*  NaN      NaN 0.00\n## rt         0.03    -0.26 2.70\n\nclass(mydata.summary[1])\n\n## [1] \"list\"  Using a single set of brackets will let us select the first item in the\nlist, but it's still of the class 'list'. It would be great if we could\ntreat that table as a data.frame, so that we can work with it using the\nother things we know. That's exactly what the double set of brackets\ndoes:  mydata.summary[[1]]\n\n##            vars  n   mean    sd median trimmed   mad   min    max range\n## id            1 25  25.00 14.72   25.0   25.00 17.79  1.00  49.00 48.00\n## condition*    2 25   1.00  0.00    1.0    1.00  0.00  1.00   1.00  0.00\n## rt            3 25 100.25 13.48  100.4  100.28 12.13 70.92 131.17 60.25\n##            skew kurtosis   se\n## id         0.00    -1.34 2.94\n## condition*  NaN      NaN 0.00\n## rt         0.03    -0.26 2.70\n\nclass(mydata.summary[[1]])\n\n## [1] \"psych\"      \"describe\"   \"data.frame\"  You'll see that the resulting object has three classes - \"psych\",\n\"describe\", and most useful for us, \"data.frame\". Now, we can use the $\nsymbol to select a column by name.  mydata.summary[[1]]$mean\n\n## [1]  25.0000   1.0000 100.2517  This selects the column of means for condition A. We're interested in\nonly the mean reaction time, so we can again use brackets to select the\nthird element:  mydata.summary[[1]]$mean[3]\n\n## [1] 100.2517  This code says to select the third element of the column named \"mean\" of\nthe content of the first item in the list \"mydata.summary\".   Now, we can change the 1 to a 2 to select the mean reaction time for\ncondition B, and combine them using  c() .  c(mydata.summary[[1]]$mean[3], mydata.summary[[2]]$mean[3])\n\n## [1] 100.25170  99.54173  We store the result in a column of our new data.frame named \"meanRT\". We\ncan do the exact same thing to select the standard error (se) of\nreaction time for each condition:  se = c(mydata.summary[[1]]$se[3], mydata.summary[[2]]$se[3]))  We end up with a data.frame that has two rows and three columns:  mydata.plot\n\n##   condition    meanRT       se\n## 1         A 100.25170 2.696155\n## 2         B  99.54173 2.712388   Now let's break down the ggplot code:  ggplot(mydata.plot, aes(x = condition, y = meanRT)) +  The  ggplot()  function creates an object of the class \"ggplot\". Here,\nwe give it two arguments. The first tells it the name of our data.frame\n(mydata.plot), and the second tells it how to arrange the data on the x\nand y axes. We want two columns representing our conditions arranged\nalong the x-axis, and the height of the bars to correspond to the mean\nreaction time in each condition. We use  aes()  to indicate this (it\nstands for  aesthetic mapping ).   We've created a ggplot object with condition on the x-axis and mean\nreaction time in the y-axis, but we haven't specified what type of plot\nwe want - a bar plot? Line plot? Something else? So, we add more to the\nggplot object with the plus sign.  geom_bar(stat= \"identity\", width = .5) +  geom_bar()  indicates that we want a bar plot. We provide two\narguments:  stat = \"identity\"  indicates that the height of the bars\nshould be exactly what's in the meanRT column, and  width = .5  sets the\nwidth of the bars to 50% of the default width.  geom_errorbar(aes(ymin = meanRT - se, ymax = meanRT + se), width = .25)  And finally, we add another line to add errorbars to the plot using the geom_errorbar()  function. Importantly, we need to specify how wide the\nbars should be using the  aes()  argument. Inside  aes() , we set the\nminimum y-value for the bars to be the mean minus the standard error\n(meanRT - se), and the maximum y-value to be the mean plus the standard\nerror (meanRT + se). We can also set the width using another argument.     ggplot2  can make many other complex visualizations. You can read more\nabout how to use it at  http://docs.ggplot2.org/current/", 
            "title": "Data Visualization with ggplot2"
        }
    ]
}